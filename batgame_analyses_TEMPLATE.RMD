---
title: "Bat Game"
subtitle: "Developed by Dr. Elizabeth Hobson, University of Cincinnati"
author: "ADD YOUR NAME HERE"
date: "`r format(Sys.time(), '%Y-%B-%d')`"
output:
  html_document:
    toc: true
    toc_depth: 3
    toc_float: true
    collapsed: false
    smooth_scroll: false
---

This section sets some formatting rules to produce the lab report
```{css, echo=FALSE}
pre {
  max-height: 300px;
  overflow-y: auto;
}

pre[class] {
  max-height: 250px;
}

.scroll-250 {
  max-height: 250px;
  overflow-y: auto;
  background-color: inherit;
}
```

Load all packages: This section loads all necessary packages (and installs them if necessary). We also load the landmarks data and do some processing to it (split by landmark type cow vs roost, which we'll use for plotting later), and view the data.
```{r}
if (!require("pacman")) install.packages("pacman")
pacman::p_load(trajr, tidyverse, gridExtra, igraph, scales, stringr, grid, rmarkdown)

#load landmark locations
landmarks <- read_csv("landmark_locations.csv") #this is a provided file

#divide landmarks by type
locs.roosts <- subset(landmarks, landmark=="tree")
locs.cows <- subset(landmarks, landmark=="cow")

```
View all landmarks: This table shows the landmark types (tree or cow), the unique identification of each landmark, the x location, the y location, and the color (we'll use this for plotting later).
```{r}
rmarkdown::paged_table(landmarks, options = NULL)
```


########### 
# PART 0: EXPLORE
########### 

In this section, you will analyze your data for the first time you play the "random movement" version of the bat game. In the first play of the game, your goal is to explore the habitat. We'll then compare your movements with the rest of the bats.

## Load, process, & view the data

Load data & process
```{r setup, warning=FALSE, class.output="scroll-250"}
explore.locs <- read_csv("explore.csv") #this is uploaded by the students

#this is example data in case student data won't run (just delete the "#" from the start of the line below)
#explore.locs <- read_csv("example_explore.csv") 


#rename cols
colnames(explore.locs) <- c("times", "agent", "x", "y")

#rename bat IDs in raw data, make bat -1 the "Player"
explore.locs$batID <- ifelse(explore.locs$agent==-1, "Player", paste("Bat", formatC(explore.locs$agent, width=2, flag="0"), sep=" "))

```


This table shows the data for the exploratory phase of the game in 5 columns: timestep (starting at 1), the ID number of each bat ("agent"), the x location, the y location, and the name of each bat ("batID").
```{r}
rmarkdown::paged_table(explore.locs, options = NULL)
```

## Plot all the trajectories
```{r fig0, fig.height = 8, fig.width = 8, fig.cap="Figure 1: Plot of all bat trajectories. for exploratory phase"}

ggplot(explore.locs, aes(x, y, group=1)) +
  #add cows and roosts first so trajectories plot over them
  geom_point(data=locs.cows, aes(x=x, y=y), colour="darkgrey", size=3, pch=16) +
  geom_point(data=locs.roosts, aes(x=x, y=y), colour="green", size=3, pch=18) +
  #add trajectories
  geom_path() +
  #scale_y_reverse() +
  xlim(0,50) +
  ylim(50,0) +
  labs(title = "Bat trajectories: random movement (explore)",
       subtitle = "Trajectories=black, roost locations=green, cow locations=grey") +
  #set theme for plots
  theme(aspect.ratio=1,
        panel.background = element_blank(),
        panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(),
        axis.line = element_line(colour = "black"),
        panel.border = element_rect(colour = "black", fill=NA, linewidth=0.5),
        legend.position="bottom", legend.direction="horizontal") +
  #facet wrap to show one trajectory per bat
  facet_wrap(~ batID,ncol = 4)
```


########### 
# PART 1: RANDOM MOVEMENTS
########### 
In this section, you will analyze your data for the second time you play the "random movement" version of the bat game. All the programmed "Non-Player Character" bats (NPCs) are programmed to move randomly. At each timestep, they choose a direction to move and move one step in that direction. 

In the second play of the game, your goal is to try to act like all the other bats and randomly move around the habitat. We'll then compare your movements with the rest of the bats to see if you were successful in following random movements.

## Load, process, & view the data

Load data & process
```{r}
rand.locs <- read_csv("random.csv") #this is uploaded by the students

#this is example data in case student data won't run (just delete the "#" from the start of the line below)
#rand.locs <- read_csv("example_random.csv") 


#rename cols
colnames(rand.locs) <- c("times", "agent", "x", "y")

#rename bat IDs in raw data, make bat -1 the "Player"
rand.locs$batID <- ifelse(rand.locs$agent==-1, "Player", paste("Bat", formatC(rand.locs$agent, width=2, flag="0"), sep=" "))

#divide landmarks by type
locs.roosts <- subset(landmarks, landmark=="tree")
locs.cows <- subset(landmarks, landmark=="cow")

#check
rmarkdown::paged_table(locs.roosts, options = NULL)
rmarkdown::paged_table(locs.cows, options = NULL)


```


This table shows the data for the random phase of the game in 5 columns: timestep (starting at 1), the ID number of each bat ("agent"), the x location, the y location, and the name of each bat ("batID").
```{r}
rmarkdown::paged_table(rand.locs, options = NULL)
```

## Plot all the trajectories
```{r fig1, fig.height = 8, fig.width = 8, fig.cap="Figure: Plot of all bat trajectories (with the goal of producing random movements)."}

ggplot(rand.locs, aes(x, y, group=1)) +
  #add cows and roosts first so trajectories plot over them
  geom_point(data=locs.cows, aes(x=x, y=y), colour="darkgrey", size=3, pch=16) +
  geom_point(data=locs.roosts, aes(x=x, y=y), colour="green", size=3, pch=18) +
  #add trajectories
  geom_path() +
  #scale_y_reverse() +
  xlim(0,50) +
  ylim(50,0) +
  labs(title = "Bat trajectories: random movement",
       subtitle = "Trajectories=black, roost locations=green, cow locations=grey") +
  #set theme for plots
  theme(aspect.ratio=1,
        panel.background = element_blank(),
        panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(),
        axis.line = element_line(colour = "black"),
        panel.border = element_rect(colour = "black", fill=NA, linewidth=0.5),
        legend.position="bottom", legend.direction="horizontal") +
  #facet wrap to show one trajectory per bat
  facet_wrap(~ batID,ncol = 4)
```


## ** Q1: Compare your trajectory to the NPC bats **
**Humans often have a lot of trouble behaving randomly. How does your trajectory ("Player" panel) compare to the NPC bats? What were some major differences between your movements and the NPC bats that were programmed to moved randomly? Did you have a strategy for behaving randomly - and if so, did it work at all?**

```
ADD YOUR ANSWER HERE

```



## Analyze the trajectories

Summarize all trajectories
```{r}
#make empty dataframe to write trajectory summaries to
trajectory.summary <- data.frame(batID=character(),
                                 distance=double(),
                                 straightness=double(),
                                 sinosoidy=double(),
                                 mean.dirchange=double())
# LOOP

# loop map: vector of animal ids
ids <- unique(rand.locs$batID)

for (bat in 1:length(ids)) { #bat=1
  #filter data for just focal bat
  loop.bat <- ids[bat]
  loop.data <- subset(rand.locs, batID==loop.bat)
  
  #format & sort data
  loop.data <- loop.data %>% 
    select(x, y, times) %>% #select just columns needed
    arrange(times)
  
  #make trajectory & summarize
  trj <- trajr::TrajFromCoords(loop.data)
  #plot(trj)
  distance        <- trajr::TrajDistance(trj)
  straightness    <- trajr::TrajStraightness(trj)
  mean.dirchange  <- mean(trajr::TrajDirectionalChange(trj))
  batID           <- loop.bat
  
  #compile data & write
  loop.compiled <- cbind.data.frame(batID, 
                                    distance, 
                                    straightness, 
                                    mean.dirchange)
  
  trajectory.summary <- rbind.data.frame(trajectory.summary, loop.compiled)
  
}
```

View data structure
```{r}
rmarkdown::paged_table(trajectory.summary, options = NULL)
```


Format the trajectory data
```{r}
#melt summaries & separate NPCs and Player summary data
melted_traj.summs <- pivot_longer(trajectory.summary, !batID, names_to = "type.mm", values_to = "value")

NPCs <- subset(melted_traj.summs, batID!="Player")
player <- subset(melted_traj.summs, batID=="Player")
```

Plot the trajectory data
```{r fig2, fig.height = 5, fig.width = 8, fig.cap="Figure: Plot of summary measures of random movements when player goal is to also move randomly."}
#distance
player.dist <- player$value[player$type.mm=="distance"]
dist <- ggplot(NPCs[NPCs$type.mm=="distance",], aes(type.mm, value)) +
  geom_boxplot(color="saddlebrown", fill="saddlebrown", alpha=0.2, outlier.shape = NA) +
  geom_jitter(width = 0.3, size=5, pch=21, col="white", bg="saddlebrown") +
  ylim(0,max(c(NPCs$value[NPCs$type.mm=="distance"]),player$value[player$type.mm=="distance"])) +
  ggtitle("Distance") + 
  ylab("Distance") +
  geom_point(aes(y=player.dist), col="black", bg="red", size=5, pch=23) +
  theme(plot.title = element_text(hjust = 0.5),
        axis.title.x=element_blank(),
        axis.text.x=element_blank(),
        axis.ticks.x=element_blank(),
        panel.background = element_blank(),
        panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(),
        axis.line = element_line(colour = "black"),
        panel.border = element_rect(colour = "black", fill=NA, linewidth=0.5))


#straightness
player.straightn <- player$value[player$type.mm=="straightness"]
straightness <- ggplot(NPCs[NPCs$type.mm=="straightness",], aes(type.mm, value)) +
  geom_boxplot(color="saddlebrown", fill="saddlebrown", alpha=0.2, outlier.shape = NA) +
  geom_jitter(width = 0.3, size=5, pch=21, col="white", bg="saddlebrown") +
  ylim(0,max(c(NPCs$value[NPCs$type.mm=="straightness"]),player$value[player$type.mm=="straightness"])) +
  ggtitle("Straightness") + 
  ylab("Straightness") +
  geom_point(aes(y=player.straightn), col="black", bg="red", size=5, pch=23) +
  theme(plot.title = element_text(hjust = 0.5),
        axis.title.x=element_blank(),
        axis.text.x=element_blank(),
        axis.ticks.x=element_blank(),
        panel.background = element_blank(),
        panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(),
        axis.line = element_line(colour = "black"),
        panel.border = element_rect(colour = "black", fill=NA, linewidth=0.5))


#direction change
player.dirchange <- player$value[player$type.mm=="mean.dirchange"]
dirchange <- ggplot(NPCs[NPCs$type.mm=="mean.dirchange",], aes(type.mm, value)) +
  geom_boxplot(color="saddlebrown", fill="saddlebrown", alpha=0.2, outlier.shape = NA) +
  geom_jitter(width = 0.3, size=5, pch=21, col="white", bg="saddlebrown") +
  ylim(0,max(c(NPCs$value[NPCs$type.mm=="mean.dirchange"]),player$value[player$type.mm=="mean.dirchange"])) +
  ggtitle("Direction change") + 
  ylab("Mean direction change") +
  geom_point(aes(y=player.dirchange), col="black", bg="red", size=5, pch=23) +
  theme(plot.title = element_text(hjust = 0.5),
        axis.title.x=element_blank(),
        axis.text.x=element_blank(),
        axis.ticks.x=element_blank(),
        panel.background = element_blank(),
        panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(),
        axis.line = element_line(colour = "black"),
        panel.border = element_rect(colour = "black", fill=NA, linewidth=0.5))


# plot all together to compare
gridExtra::grid.arrange(dist, straightness, dirchange, ncol=4,
                        top=textGrob("Bat trajectories: random movement"))

```

## ** Q2: Compare your movements to the NPC bats **
**How does the summary of your movements ("Player" points, in red) compare to the NPC bats? Are you acting "normally" in this social world, compared to the programmed bats? What aspects were similar or different compared to the programmed bats?** 
```
ADD YOUR ANSWER HERE

```

**What aspects of your movements were similar or different compared to the programmed bats? For each measure, was your pattern higher or lower than the programmed bats?**
```
ADD YOUR ANSWER HERE

```

## Use location data to find distances between bats and landmarks

Find distances between each bat and all landmarks at each time step
```{r}

   ts <- seq(0,750)
    ev10steps <- ts[(ts %% 10) == 0]
    ev10steps <- ev10steps[2:length(ev10steps)]
    
    
   #clean landmarks
    landmarks.tr <- subset(landmarks, select=c(landmark, landmarkID, x, y))
    colnames(landmarks.tr) <- c("landmark", "landmarkID", "land.x", "land.y")  
    
    #make an empty dataframe to write to
    distance_landmarks <- data.frame(times=integer(),
                                     batID=character(),
                                     landmark=character(),
                                     landmarkID=character(),
                                     dist.class=character())
    
    #Loop over all bat locations to find distances between each bat and each landmark
    for (step in 2:length(ev10steps)) { #step=1
      loop.step <- ev10steps[step]
      
      #if no data at that timestep, skip
      loop.data <- if(nrow(subset(rand.locs, times==loop.step))<1) next #skip if no data at this ts
      
      #otherwise, subset the data
      loop.data <- subset(rand.locs, times==loop.step)
      
      #find distance from bats to all landmarks
      landmark.combos <- merge(loop.data, landmarks.tr)
      landmark.combos <- landmark.combos %>% mutate(dist=sqrt((x-land.x)^2 + (y-land.y)^2))
      #set categories of "near" or "not near" based on distance to them
      landmark.combos$dist.class <- ifelse(landmark.combos$dist<=5, "near", "not.near")
      
      #if no landmarks are near, skip to the next timestep
      if(nrow(subset(landmark.combos, dist.class=="near"))<1) next #skip if no bats are near
      
      #if any landmarks are near, subset the data
      landmark.combos.sub <- subset(landmark.combos, dist.class=="near")
      landmark.combos.subtr <- subset(landmark.combos.sub, select=c(times, batID, landmark, landmarkID, dist.class))
      
      
      #write data to save
      distance_landmarks <- rbind.data.frame(distance_landmarks, landmark.combos.subtr)
      
    }

```

## Summarize proximity to landmarks

```{r}
#summarize how many times each bat was near a roost or cow, and how many of each it visited
summ_landmarks <- distance_landmarks %>% group_by(batID, landmark, landmarkID) %>%
  summarize(times.near=n())

unique.landmarks <- summ_landmarks %>% group_by(batID, landmark) %>% summarize(unique.visitsXtype=n())
unique.landmarks_cows <- subset(unique.landmarks, landmark=="cow")

all.bats <- as.data.frame(unique(rand.locs$batID))
colnames(all.bats) <- "batID"

unique.landmarks_cows <- merge(all.bats, unique.landmarks_cows, by="batID", all.x=TRUE, fill=0)
unique.landmarks_cows$unique.visitsXtype[is.na(unique.landmarks_cows$unique.visitsXtype)] <- 0

rmarkdown::paged_table(unique.landmarks_cows, options = NULL)

mean.NPC.cows <- mean(unique.landmarks_cows$unique.visitsXtype[unique.landmarks_cows$batID!="Player"])
n.player.cows <-unique.landmarks_cows$unique.visitsXtype[unique.landmarks_cows$batID=="Player"]
```

## Plot number of cows each bat found
```{r,fig.cap="Figure: Plot of the number of cows discovered by each bat when movements are random."}
#plot number of cows discovered
ggplot(unique.landmarks_cows, aes(x=batID, y=unique.visitsXtype, 
                                  fill = ifelse(batID == "Player", "Player", "NPC bats"))) +
  geom_bar(stat="identity") +
  labs(x="Bats", 
       y="Number of cows found", 
       title = "Bat trajectories: random movement") +
  ## add manual color scale
  scale_fill_manual("legend",         ###### in this call: colour change
                    values = c("Player" = "red", "NPC bats" = "saddlebrown")) +
  theme(plot.title = element_text(hjust = 0.5),
        panel.grid.major.y = element_line(color = "grey",
                                          linewidth = 0.5,
                                          linetype = 1),
        axis.line = element_line(colour = "black"),
        panel.border = element_rect(colour = "black", fill=NA, linewidth=0.5),
        legend.position="bottom",
        axis.text.x=element_text(angle = 90, vjust = 0.5, hjust=1)) +
  annotate("text", x=1, y=7, hjust = 0,
           label= paste0("Mean number cows found by NPC bats = ", round(mean.NPC.cows,2))) +
  annotate("text", x=1, y=6.5, hjust = 0,
           label= paste0("Number cows found by player = ", n.player.cows))
```


## ** Q3: Random movement foraging success **

**How many cows did you visit while foraging?**
```
ADD YOUR ANSWER HERE

```

**Did any other bats find cows?**
```
ADD YOUR ANSWER HERE

```

**Which other bats were successful foragers and how many cows did they find?**  
```
ADD YOUR ANSWER HERE

```
**Is moving randomly around the habitat a successful foraging strategy that you'd expect real bats to use? Why or why not?**
```
ADD YOUR ANSWER HERE

```


########### 
# PART 2: SOCIAL FORAGING 
############
When you played the first two versions of the random movements game, all the NPC bats were programmed to just move randomly around the habitat, without responding to anything in the habitat. In the "Social Foraging" version of the game, the NPC bats have new rules that they use to structure their movements. Each NPC bat is assigned a "buddy". NPC bats now have two goals: they need to find cows to forage on, but they also prefer to forage with their assigned buddy. 

In this game, activate the game and wait 10 seconds. Watch how the bats start to move around the habitat. Use this time to pick one bat to be your "buddy". Once the 10 seconds have passed, you will use the same rules that the NPC bats use: your goal is to move around and find cows to feed on, but you also need to stay close to the bat you've chosen as your buddy.

# Load, process, & view the data

Load data & process
```{r warning=FALSE}
socfor.locs <- read_csv("socforag.csv") #this is uploaded by the students #SOCFORG.csv

#this is example data in case student data won't run (just delete the "#" from the start of the line below)
#socfor.locs <- read_csv("example_socforag.csv") 

#rename cols
colnames(socfor.locs) <- c("times", "agent", "x", "y")

#rename bat IDs in raw data, make bat -1 the "Player"
socfor.locs$batID <- ifelse(socfor.locs$agent==-1, "Player", paste("Bat", formatC(socfor.locs$agent, width=2, flag="0"), sep=" "))

```

This table shows the data for the social foraging phase of the game in 5 columns: timestep (starting at 1), the ID number of each bat ("agent"), the x location, the y location, and the name of each bat ("batID").
```{r}
rmarkdown::paged_table(socfor.locs, options = NULL)

```

# Plot all the trajectories 
```{r fig6, fig.height = 10, fig.width = 8, fig.cap="Figure: Plot of all bat trajectories (social foraging)."}

ggplot(socfor.locs, aes(x, y, group=1)) +
  #add cows and roosts first so trajectories plot over them
  geom_point(data=locs.cows, aes(x=x, y=y), colour="darkgrey", size=3, pch=16) +
  geom_point(data=locs.roosts, aes(x=x, y=y), colour="green", size=3, pch=18) +
  #add trajectories
  geom_path() +
  #scale_y_reverse() +
  xlim(0,50) +
  ylim(50,0) +
  labs(title = "Bat trajectories: social foraging",
       subtitle = "Trajectories=black, roost locations=green, cow locations=grey") +
  #set theme for plots
  theme(aspect.ratio=1,
        panel.background = element_blank(),
        panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(),
        axis.line = element_line(colour = "black"),
        panel.border = element_rect(colour = "black", fill=NA, linewidth=0.5),
        legend.position="bottom", legend.direction="horizontal") +
  #facet wrap to show one trajectory per bat
  facet_wrap(~ batID,ncol = 4)
```

## ** Q4: Compare your trajectory to the NPC bats **
**Now that you are not trying to move randomly, how does your trajectory compare to the NPC bats?**

```
ADD YOUR ANSWER HERE

```


## Analyze trajectories

Summarize all trajectories
```{r}
#make empty dataframe to write trajectory summaries to
trajectory.summary <- data.frame(batID=character(),
                                 distance=double(),
                                 straightness=double(),
                                 sinosoidy=double(),
                                 mean.dirchange=double())
# LOOP

# loop map: vector of animal ids
ids <- unique(socfor.locs$batID)

for (bat in 1:length(ids)) { #bat=1
  #filter data for just focal bat
  loop.bat <- ids[bat]
  loop.data <- subset(socfor.locs, batID==loop.bat)
  
  #format & sort data
  loop.data <- loop.data %>% 
    select(x, y, times) %>% #select just columns needed
    arrange(times)
  
  #make trajectory & summarize
  trj <- trajr::TrajFromCoords(loop.data)
  #plot(trj)
  distance        <- trajr::TrajDistance(trj)
  straightness    <- trajr::TrajStraightness(trj)
  sinosoidy       <- trajr::TrajSinuosity2(trj)
  mean.dirchange  <- mean(trajr::TrajDirectionalChange(trj))
  batID           <- loop.bat
  
  #compile data & write
  loop.compiled <- cbind.data.frame(batID, 
                                    distance, 
                                    straightness, 
                                    sinosoidy, 
                                    mean.dirchange)
  
  trajectory.summary <- rbind.data.frame(trajectory.summary, loop.compiled)
  
}
```

View data structure
```{r}
rmarkdown::paged_table(trajectory.summary, options = NULL)

```


Format the trajectory data
```{r}
#melt summaries & separate NPCs and Player summary data
melted_traj.summs <- pivot_longer(trajectory.summary, !batID, names_to = "type.mm", values_to = "value")

NPCs <- subset(melted_traj.summs, batID!="Player")
player <- subset(melted_traj.summs, batID=="Player")
```

Plot the trajectory data
```{r fig7, fig.height = 5, fig.width = 10}
#distance
player.dist <- player$value[player$type.mm=="distance"]
dist <- ggplot(NPCs[NPCs$type.mm=="distance",], aes(type.mm, value)) +
  geom_boxplot(color="saddlebrown", fill="saddlebrown", alpha=0.2, outlier.shape = NA) +
  geom_jitter(width = 0.3, size=5, pch=21, col="white", bg="saddlebrown") +
  ylim(0,max(c(NPCs$value[NPCs$type.mm=="distance"]),player$value[player$type.mm=="distance"])) +
  ggtitle("Distance") + 
  ylab("Distance") +
  geom_point(aes(y=player.dist), col="black", bg="red", size=5, pch=23) +
  theme(plot.title = element_text(hjust = 0.5),
        axis.title.x=element_blank(),
        axis.text.x=element_blank(),
        axis.ticks.x=element_blank(),
        panel.background = element_blank(),
        panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(),
        axis.line = element_line(colour = "black"),
        panel.border = element_rect(colour = "black", fill=NA, linewidth=0.5))


#straightness
player.straightn <- player$value[player$type.mm=="straightness"]
straightness <- ggplot(NPCs[NPCs$type.mm=="straightness",], aes(type.mm, value)) +
  geom_boxplot(color="saddlebrown", fill="saddlebrown", alpha=0.2, outlier.shape = NA) +
  geom_jitter(width = 0.3, size=5, pch=21, col="white", bg="saddlebrown") +
  ylim(0,max(c(NPCs$value[NPCs$type.mm=="straightness"]),player$value[player$type.mm=="straightness"])) +
  ggtitle("Straightness") + 
  ylab("Straightness") +
  geom_point(aes(y=player.straightn), col="black", bg="red", size=5, pch=23) +
  theme(plot.title = element_text(hjust = 0.5),
        axis.title.x=element_blank(),
        axis.text.x=element_blank(),
        axis.ticks.x=element_blank(),
        panel.background = element_blank(),
        panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(),
        axis.line = element_line(colour = "black"),
        panel.border = element_rect(colour = "black", fill=NA, linewidth=0.5))


#direction change
player.dirchange <- player$value[player$type.mm=="mean.dirchange"]
dirchange <- ggplot(NPCs[NPCs$type.mm=="mean.dirchange",], aes(type.mm, value)) +
  geom_boxplot(color="saddlebrown", fill="saddlebrown", alpha=0.2, outlier.shape = NA) +
  geom_jitter(width = 0.3, size=5, pch=21, col="white", bg="saddlebrown") +
  ylim(0,max(c(NPCs$value[NPCs$type.mm=="mean.dirchange"]),player$value[player$type.mm=="mean.dirchange"])) +
  ggtitle("Direction change") + 
  ylab("Mean direction change") +
  geom_point(aes(y=player.dirchange), col="black", bg="red", size=5, pch=23) +
  theme(plot.title = element_text(hjust = 0.5),
        axis.title.x=element_blank(),
        axis.text.x=element_blank(),
        axis.ticks.x=element_blank(),
        panel.background = element_blank(),
        panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(),
        axis.line = element_line(colour = "black"),
        panel.border = element_rect(colour = "black", fill=NA, linewidth=0.5))


# plot all together to compare
gridExtra::grid.arrange(dist, straightness, dirchange, ncol=4,
                        top=textGrob("Bat trajectories: social foraging"))

```


## ** Q5: Compare your movement summaries to the NPC bats **
**Now that you are not trying to move randomly, how does your trajectory compare to the NPC bats? How does the summary of your movements ("Player" points, in red) compare to the NPC bats? Are you acting "normally" in this social world, compared to the programmed bats?**  
```
ADD YOUR ANSWER HERE

```

**What aspects of your movements were similar or different compared to the programmed bats? For each measure, was your pattern higher or lower than the programmed bats?**
```
ADD YOUR ANSWER HERE

```



# Find distances between bats and landmarks

Use the locations to find the distances between each bat and all landmarks at each time step
```{r}

   ts <- seq(0,750)
    ev10steps <- ts[(ts %% 10) == 0]
    ev10steps <- ev10steps[2:length(ev10steps)]
    
    
   #clean landmarks
    landmarks.tr <- subset(landmarks, select=c(landmark, landmarkID, x, y))
    colnames(landmarks.tr) <- c("landmark", "landmarkID", "land.x", "land.y")  
    
    #make an empty dataframe to write to
    distance_landmarks <- data.frame(times=integer(),
                                     batID=character(),
                                     landmark=character(),
                                     landmarkID=character(),
                                     dist.class=character())
    
    #Loop over all bat locations to find distances between each bat and each landmark
    for (step in 2:length(ev10steps)) { #step=1
      loop.step <- ev10steps[step]
      
      #if no data at that timestep, skip
      loop.data <- if(nrow(subset(socfor.locs, times==loop.step))<1) next #skip if no data at this ts
      
      #otherwise, subset the data
      loop.data <- subset(socfor.locs, times==loop.step)
      
      #find distance from bats to all landmarks
      landmark.combos <- merge(loop.data, landmarks.tr)
      landmark.combos <- landmark.combos %>% mutate(dist=sqrt((x-land.x)^2 + (y-land.y)^2))
      #set categories of "near" or "not near" based on distance to them
      landmark.combos$dist.class <- ifelse(landmark.combos$dist<=5, "near", "not.near")
      
      #if no landmarks are near, skip to the next timestep
      if(nrow(subset(landmark.combos, dist.class=="near"))<1) next #skip if no bats are near
      
      #if any landmarks are near, subset the data
      landmark.combos.sub <- subset(landmark.combos, dist.class=="near")
      landmark.combos.subtr <- subset(landmark.combos.sub, select=c(times, batID, landmark, landmarkID, dist.class))
      
      
      #write data to save
      distance_landmarks <- rbind.data.frame(distance_landmarks, landmark.combos.subtr)
      
    }
    
#View results
rmarkdown::paged_table(distance_landmarks, options = NULL)


```

## Summarize proximity to landmarks

```{r}
#summarize how many times each bat was near a roost or cow, and how many of each it visited
summ_landmarks <- distance_landmarks %>% group_by(batID, landmark, landmarkID) %>%
  summarize(times.near=n())

unique.landmarks <- summ_landmarks %>% group_by(batID, landmark) %>% summarize(unique.visitsXtype=n())
unique.landmarks_cows <- subset(unique.landmarks, landmark=="cow")

all.bats <- as.data.frame(unique(socfor.locs$batID))
colnames(all.bats) <- "batID"

unique.landmarks_cows <- merge(all.bats, unique.landmarks_cows, by="batID", all.x=TRUE, fill=0)
unique.landmarks_cows$unique.visitsXtype[is.na(unique.landmarks_cows$unique.visitsXtype)] <- 0

mean.NPC.cows <- mean(unique.landmarks_cows$unique.visitsXtype[unique.landmarks_cows$batID!="Player"])
n.player.cows <-unique.landmarks_cows$unique.visitsXtype[unique.landmarks_cows$batID=="Player"]
```

## Plot number of cows each bat found
```{r}
#plot number of cows discovered
ggplot(unique.landmarks_cows, aes(x=batID, y=unique.visitsXtype, 
                                  fill = ifelse(batID == "Player", "Player", "NPC bats"))) +
  geom_bar(stat="identity") +
  labs(x="Bats", 
       y="Number of cows found", 
       title = "Bat trajectories: social foraging") +
  ## add manual color scale
  scale_fill_manual("legend",         ###### in this call: colour change
                    values = c("Player" = "red", "NPC bats" = "saddlebrown")) +
  theme(plot.title = element_text(hjust = 0.5),
        panel.grid.major.y = element_line(color = "grey",
                                          linewidth = 0.5,
                                          linetype = 1),
        axis.line = element_line(colour = "black"),
        panel.border = element_rect(colour = "black", fill=NA, linewidth=0.5),
        legend.position="bottom",
        axis.text.x=element_text(angle = 90, vjust = 0.5, hjust=1)) +
  annotate("text", x=1, y=7, hjust = 0,
           label= paste0("Mean number cows found by NPC bats = ", round(mean.NPC.cows,2))) +
  annotate("text", x=1, y=6.5, hjust = 0,
           label= paste0("Number cows found by player = ", n.player.cows))
```

## ** Q6: Social foraging success **

**How many cows did you visit while foraging?**  
```
ADD YOUR ANSWER HERE

```

**Did any other bats find cows?**
```
ADD YOUR ANSWER HERE

```

**Which other bats were successful foragers and how many cows did they find?**  
```
ADD YOUR ANSWER HERE

```
**Is social foraging potentially a successful foraging strategy that you'd expect real bats to use? Why or why not?**
```
ADD YOUR ANSWER HERE

```

# Use location data to find distances between all bats
```{r}
   #for each timestep expand.grid to find all id combos, delete same ids
    ts <- seq(0,750)
    ev10steps <- ts[(ts %% 10) == 0]
    ev10steps <- ev10steps[2:length(ev10steps)]
    

    distance_bats <- data.frame(time=integer(),
                                batA=character(),
                                batB=character(),
                                dist.class=character())
    
    
    for (step in 1:length(ev10steps)) { #step=41
      loop.step <- ev10steps[step]
      #if no data at that timestep, skip
      loop.data <- if(nrow(subset(socfor.locs, times==loop.step))<1) next #skip if no data at this ts
      #otherwise, subset the data
      loop.data <- subset(socfor.locs, times==loop.step) 
      
      #find distance from each bat to each other bat
      loop.data$joiner <- 1
      all.combos <- merge(loop.data, loop.data, by="joiner")
      all.combos <- subset(all.combos, batID.x!=batID.y)
      all.combos <- all.combos %>% mutate(dist=sqrt((x.x-x.y)^2 + (y.x-y.y)^2))
      all.combos$dist.class <- ifelse(all.combos$dist<=5, "near", "not.near")
      
      #if no bats are near, skip to the next timestep
      all.combos.sub <- if(nrow(subset(all.combos, dist.class=="near"))<1) next #skip if no bats are near
      #if any bats are near, subset the data
      all.combos.sub <- subset(all.combos, dist.class=="near")
      
      all.combos.sub.tr <- subset(all.combos.sub, select=c(times.x, batID.x, batID.y, dist.class))
      colnames(all.combos.sub.tr) <- c("time", "batA", "batB", "dist.class")
      
      #write data to save
      distance_bats <- rbind.data.frame(distance_bats, all.combos.sub.tr)
      
    }

# view data structure
rmarkdown::paged_table(distance_bats, options = NULL)

```



# Summarize inter-bat proximities & compare network measures 

Now we'll quantify and plot the social networks for the bats in the social foraging game. These networks will summarize the proximity network, where we'll count the number of times each bat was observed as "near" other bats. The bats will be the "nodes" in the network (plotted as circles) and the proximity observations will be the "edges" (plotted as lines connecting the nodes). The width of each edge will represent how often those two bats were seen in close proximity to each other. Bats that are often seen close together will have wider edges connecting them, bats that are rarely observed close together will have narrow edges connecting them, and bats that are never seen together will not have a connection.

We'll used network metrics to quantify two social measures: "degree" and "strength". 

Degree quantifies how many others each individual is connected to in the network, and represents a count of the nodes each individual is directly connected to. Here, each bat's degree is the total number of other bats that it was ever recorded as "near". A bat with a degree of 3 was observed "near" 3 other bats.

Strength quantifies how often individuals are connected to others in the network and represents the sum of all the weights of the edges in the network.
```{r}
# set up attributes

all.bats <- as.data.frame(unique(socfor.locs$batID))
colnames(all.bats) <- "batID"

all.bats$node.type <- ifelse(all.bats$batID=="Player", "Player", "NPC Bat")
all.bats$node.color <- ifelse(all.bats$batID=="Player", "red", "saddlebrown")
all.bats$bat.name <- ifelse(all.bats$batID=="Player", "ME", str_sub(all.bats$batID, start= -2))

summary_social <- distance_bats %>% group_by(batA, batB) %>%
  summarize(n.near =n())

# view data structure
head(summary_social)


g <- graph_from_data_frame(summary_social, directed=FALSE) 
g
g <- as.undirected(g, mode="mutual")

# add attributes
V(g)$bat.name <- all.bats[match(V(g)$name, all.bats$batID), "bat.name"]
V(g)$node.color <- all.bats[match(V(g)$name, all.bats$batID), "node.color"]

de <- igraph::degree(g)/2
strength <- strength(g, weights=E(g)$n.near)/2

edge_density(g)

# How social is each bat?
# add summary for n bats near ("degree") and n times near any bat??? TKTK
network_summs <- data.frame(batID=V(g)$name, n.bats.near=de, times.near.others=strength)

# view data structure
rmarkdown::paged_table(network_summs, options = NULL)
```

## Plot network summaries
```{r}
NPCs.netsum <- subset(network_summs, batID!="Player")
player.netsum <- subset(network_summs, batID=="Player")


#degree
player_degree <- player.netsum$n.bats.near
plot_degree <- ggplot(NPCs.netsum, aes(5, n.bats.near)) +
  geom_boxplot(color="saddlebrown", fill="saddlebrown", alpha=0.2, outlier.shape = NA) +
  geom_jitter(width = 0.3, size=5, pch=21, col="white", bg="saddlebrown") +
  ylim(0,max(c(NPCs.netsum$n.bats.near,player.netsum$n.bats.near))) +
  ggtitle("Network degree") + 
  ylab("Number of unique bats encountered") +
  geom_point(aes(y=player_degree, x=5), col="black", bg="red", size=5, pch=23) +
  #  geom_point(aes(y=player.dirchange), col="black", bg="red", size=5, pch=23) +
  
  theme(plot.title = element_text(hjust = 0.5),
        axis.title.x=element_blank(),
        axis.text.x=element_blank(),
        axis.ticks.x=element_blank(),
        panel.background = element_blank(),
        panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(),
        axis.line = element_line(colour = "black"),
        panel.border = element_rect(colour = "black", fill=NA, linewidth=0.5))

#strength
player_strength <- player.netsum$times.near.others
plot_strength <- ggplot(NPCs.netsum, aes(5, times.near.others)) +
  geom_boxplot(color="saddlebrown", fill="saddlebrown", alpha=0.2, outlier.shape = NA) +
  geom_jitter(width = 0.3, size=5, pch=21, col="white", bg="saddlebrown") +
  ylim(0,max(c(NPCs.netsum$times.near.others,player.netsum$times.near.others))) +
  ggtitle("Network strength") + 
  ylab("Number encounters with other bats") +
  geom_point(aes(y=player_strength, x=5), col="black", bg="red", size=5, pch=23) +
  #  geom_point(aes(y=player.dirchange), col="black", bg="red", size=5, pch=23) +
  
  theme(plot.title = element_text(hjust = 0.5),
        axis.title.x=element_blank(),
        axis.text.x=element_blank(),
        axis.ticks.x=element_blank(),
        panel.background = element_blank(),
        panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(),
        axis.line = element_line(colour = "black"),
        panel.border = element_rect(colour = "black", fill=NA, linewidth=0.5))

# plot all together to compare
gridExtra::grid.arrange(plot_degree, plot_strength, ncol=2,
                        top=textGrob("Bat trajectories: social foraging"))
```

## ** Q7: Compare network metrics **
**For social foraging, compare your social measures to the NPC bats. Were you behaving "normally" compared to the other bats? If not, how did your movements cause you to have different social measures than the NPC bats?**
```
ADD YOUR ANSWER HERE

```

## Plot proximity network
Plot bat-to-bat proximity network for all "near" events. In this plot, we'll summarize all the times each bat was ever near each other bat.
```{r fig9, fig.height = 8, fig.width = 8}
#Plot the network
set.seed(42)
plot(g, 
     edge.width=E(g)$n.near/3,
     edge.color=alpha("black", 0.4),
     main= "Social foraging proximity network (all near events)", 
     sub=paste0("Network density = ", round(edge_density(g),2)),
     vertex.size=17,
     vertex.color=V(g)$node.color,
     vertex.label.family="Arial Black",
     vertex.label.font=2,
     vertex.label.cex=0.75,
     vertex.label=V(g)$bat.name, 
     vertex.label.color="white",
     edge.curved=FALSE)

```
## ** Q8: Interpret full proximity network **
**What do you notice about this network? Is it easy to tell which who each bat's buddies are?** 
```
ADD YOUR ANSWER HERE

```

**Why are there so many connections in the network? What does that tell you about how the bats are moving around in relation to each other?**
```
ADD YOUR ANSWER HERE

```
## Plot the proximity network without rare connections

Now we are going to remove some of the rarer proximity observations. This is often called "thresholding" in network analysis. We'll use a threshold of 10: the code below deletes any connections between bats who were "near" each other less than 10 times during the game. 

We'll then plot this bat-to-bat proximity network with these rarer proximity connections removed.

```{r fig9b, fig.height = 8, fig.width = 8}

g2 <- delete.edges(g, which(E(g)$n.near <10))

#Plot the network
set.seed(42)
plot(g2, 
     edge.width=E(g2)$n.near/3,
     edge.color=alpha("black", 0.4),
     main= "Bat trajectories: social foraging", 
     #sub=paste0("Network density = ", round(edge_density(g),2)),
     vertex.size=17,
     vertex.color=V(g2)$node.color,
     vertex.label.family="Arial Black",
     vertex.label.font=2,
     vertex.label.cex=0.75,
     vertex.label=V(g2)$bat.name, 
     vertex.label.color="white",
     edge.curved=FALSE)

```

# Find strongest-preferred bats & plot

Find each bat's strongest partner
```{r}
top.associate <- summary_social %>% group_by(batA) %>%
  filter(n.near == max(n.near)) %>%
  arrange(batA)

rmarkdown::paged_table(top.associate, options = NULL)

```

Plot strongest partners
```{r fig10, fig.height = 8, fig.width = 8}
#set max axes for better labeling
max.y <- max(top.associate$n.near)+6

#barplot most-preferred associates and how often each bat was near their preferred
top.assos <- ggplot(top.associate, aes(x=batB, y=n.near, group=1, fill = ifelse(batA == "Player", "Player", "NPC bats"))) +
  geom_bar(stat="identity") +
  geom_text(aes(label = stringr::str_wrap(batB, 3)), 
            vjust = -0.2, 
            colour = "black",
            size=3,
            fontface = "italic") +
  ylim(0,max.y) + #set y limits for nicer labels
  labs(title="Stongest-preferred associates", 
       subtitle= "Bat trajectories: social foraging",
       x="Bats", 
       y="Number observations near favorite") +
  ## add manual color scale
  scale_fill_manual("legend",  
                    values = c("Player" = "red", "NPC bats" = "saddlebrown")) +
  theme(plot.title = element_text(hjust = 0.5),
        panel.grid.major.y = element_line(color = "grey",
                                          linewidth = 0.5,
                                          linetype = 1),
        axis.line = element_line(colour = "black"),
        panel.border = element_rect(colour = "black", fill=NA, linewidth=0.5),
        legend.position="bottom",
        axis.text.x=element_text(angle = 90, vjust = 0.5, hjust=1),
        aspect.ratio=1) +
  facet_wrap(~ batA,ncol = 5)

top.assos
```

## Compare two trajectories
To visualize how well you matched the movements of your "buddy" you chose, we'll plot your trajectory in red and your buddy's trajectory in brown. 

This code chunk processes the data and finds your buddy ("top associate"):
```{r}
top.associate.player <- subset(top.associate, batA=="Player")

player.top.assoIDs <- top.associate.player$batB # make a vector of names of all the player's top associates

topasso.locs <- socfor.locs[socfor.locs$batID %in% player.top.assoIDs,] # subset the location data to only include player's top associate data

colnames(topasso.locs) <- c("times", "agent", "x", "y", "top.assoID")

unique(topasso.locs$batID) # check that it worked!

player.locs <- subset(socfor.locs, batID=="Player") # subset the location data to only include player's data
  
unique(player.locs$batID) # check that it worked!

```

This code chunk plots both trajectories:
```{r fig11, fig.height = 8, fig.width = 8}

# test

under <- ggplot(player.locs, aes(x, y)) +
  geom_path(colour="red", linewidth=1.5, alpha=0.45) +
  xlim(0,50) +
  ylim(50,0) +
  labs(title = "Bat trajectories: social foraging, top associates of Player",
       subtitle = "Trajectories: Red=Player, Brown=Top associates; roost locations=green, cow locations=grey") +
  #set theme for plots
  theme(aspect.ratio=1,
        panel.background = element_blank(),
        panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(),
        axis.line = element_line(colour = "black"),
        panel.border = element_rect(colour = "black", fill=NA, linewidth=0.5),
        legend.position="bottom", legend.direction="horizontal") 

upper <- under + 
        geom_path(data=topasso.locs, aes(x=x, y=y, group=top.assoID), colour="saddlebrown", linewidth=1.0,) +
        #add cows and roosts first so they plot over trajectories
        geom_point(data=locs.cows, aes(x=x, y=y), colour="darkgrey", size=3, pch=16) +
        geom_point(data=locs.roosts, aes(x=x, y=y), colour="green", size=3, pch=18) +
        facet_wrap(~ top.assoID) 

upper
  
```

# Final questions

## ** Q9: Foraging rules & surviving as a bat**
**In the social foraging game, you had two "rules" you used to make your movement decisions: you wanted to find cows to forage on and you wanted to stay relatively close to your chosen "buddy". Real bats can use similar rules to structure their movements, or may do something different. What rules would you need in the following scenarios?**

**Scenario 1: Preferred roostmates do not coordinate movements outside the roost while foraging.** 

**What rules should the player and the NPC bats follow in a game like Scenario 1?**
```
ADD YOUR ANSWER HERE
```

**If you were a researcher in the field studying these bats, how could you tell whether bats were following Scenario 1? What would you look for? How would you tell which bats preferred each other?**
```
ADD YOUR ANSWER HERE
```

**Scenario 2: Preferred roostmates coordinate their departures from the roost but avoid foraging with each other** 

**What rules should the player and the NPC bats follow in a game like Scenario 2?**
```
ADD YOUR ANSWER HERE
```

**If you were a researcher in the field studying these bats, how could you tell whether bats were following Scenario 2? What would you look for? How would you tell which bats preferred each other?**
```
ADD YOUR ANSWER HERE
```

**Scenario 3: All roostmates depart and forage as a group.**

**What rules should the player and the NPC bats follow in a game like Scenario 3?**

```
ADD YOUR ANSWER HERE
```

**If you were a researcher in the field studying these bats, how could you tell whether bats were following Scenario 3? What would you look for? How would you tell which bats preferred each other?**
```
ADD YOUR ANSWER HERE
```

## **Q10: Long-term social strategies for survival

**Vampire bats can share food with each other if one bat isn't successful at foraging, but generally only share blood when they have a strong relationship. Food sharing occurs after foraging once bats have returned to the roost. If you are a bat living in an uncertain environment, where your changes of being unsuccessful at foraging and needing food sharing are higher, what social strategies could you use to increase your chances of survival?**

**How would you change your foraging patterns to increase your chances of survival? What strategy would you use and what rules would you use to move around?**
```
ADD YOUR ANSWER HERE
```

**How would you change your roosting patterns to increase your chances of survival? What strategy would you use and what rules would you use to decide which roost to use and who to share a roost with?**
```
ADD YOUR ANSWER HERE
```