---
title: "Bat Game"
subtitle: "Using online games to learn about sociality, movement, and basic coding"
author: "ADD YOUR NAME HERE"
date: "`r format(Sys.time(), '%Y-%B-%d')`"
output:
  html_document:
    toc: true
    toc_depth: 3
    toc_float: true
    collapsed: false
    smooth_scroll: false
---

```{r pressure, echo=FALSE, fig.cap="For more information, visit http://hobsonresearch.com/index.php/sociality-game/", out.width = '100%'}
knitr::include_graphics("sociality.game.logo.png")
```

########### 
# First task
########### 
Add your name to the header text (in green) above where it says "ADD YOUR NAME HERE". Make sure you keep the quotation marks around your name! This code at the top will print out information when you compile your lab report at the end, once you have finished all the activities. Line 5 shows code that will add the current date whenever you knit the file.


########### 
# Lab objectives
########### 
**1. Convince you that data science and coding skills are valuable for biologists and worth learning.**

**2. Provide you with basic natural history information for Vampire Bats, a fascinating species where individuals form relationships, engage in cooperative food sharing, and use social foraging.**

**3. Explore animal social interactions in online experiments -- These "games" examine the outcomes of several "social rules" to see how changing your goals affects how individuals interact with each other.**  

**4. Gently introduce you to the R code underlying the analyses, and provide a sampling of the power of custom analyses that is possible when coding.**


########### 
# A gentle introduction to the basics of R
########### 
If you have never coded before, don't worry! This lab will allow you to use custom analyses in a way that walks you through the code, but doesn't require you to actually write any code. This lab is specifically targeted to complete beginners in R.

R is a coding language that is widely used in biological research. It's particulary good at both statistical analyses and plotting data in customized ways. Knowing how to code can give students important advantages and make them more competitive on the job market both in academia as well as in a wide range of non-academic careers. Beyond being an important skill, it can also make your science more reproducible because you have a record of everything that you did to wrangle your data, plot your plots, and analyze your statistics. Don't worry, we are not doing any stats today -- we're focusing just on data wrangling, summarizing, and plotting.

Here are some quirks about R that you should know to get started:

- R is very sensitive to capitalization and spelling/type-os. If you are told to save data as "random.csv" and instead save it as "Random.csv", the code provided here will fail! If you get an error, check for type-os or differences between your file names in your project and the file names in the code - these must be exactly the same.

- We are working in an R Markdown file. This is a nice way to combine code chunks and text blocks. At the end of the lab, you will "Knit" the file which will compile all the code, plots, tables, results, and your answers to all the questions into a single HTML file which you will submit. These are viewable in your browser.

- In the markdown file, all code appears in grey boxes enclosed by backquote or backtick symbols (see more information about this symbol here: https://www.computerhope.com/jargon/b/backquot.htm). There are three backquote symbols at the start of the code block and three backquote symbols at the end of the code block. Don't delete these! Your answer text blocks are also enclosed with these backquote symbols (just replace the "YOUR ANSWER HERE" text with your own answer)

- To run each code block, first read the explanation. Then click the "play button" on the right-hand side of the screen to run that chunk. You will see a stop sign appear while the code is running and a green line will display on the left side of the screen to show progress on running the code. Once a code chunk has run, the results will display under the code chunk (the table or plot will show). You do not need to click the "play button" to run your answers to questions (that will be run at the end when you Knit the whole file).

- Notes appear within the grey code blocks as green text with a "#" sign in front of it. This is a way to add annotations and notes into R code - R will not run whatever is on the same line behind the # symbol

- Make sure you read each section! These descriptions provide a walk-through of the code and important information for each part of the lab

- Watch for questions -- These are all labeled "**Q..." and will appear as bright blue text within the R Markdown file. Make sure you respond to each of the questions and answer the question in the space provided (just replace the "YOUR ANSWER HERE" text with your own answer -- DO NOT DELETE the backquote symbols and make sure they stay on their own lines without any extra text on them!)

- MAKE SURE YOU SAVE YOUR WORK!!


########### 
# An introduction to vampire bats
########### 
Vampire bats are incredibly fascinating animals. For the lab today, the main points you need to know are:

- Vampire bats feed on blood to survive

- They roost in tree cavities during the day and fly around to forage on cattle at night

- Without enough food, vampire bats can starve quickly

- If a vampire bat wasn't able to drink enough blood, its friends can share food with it

- This cooperation appears to be reciprocal within these friendships

Gerry Carter has spent his career specializing on vampire bat cooperation and sociality. For more information on his research, see https://socialbat.org/research/


## Vampire bat video links
Here are links to the first two videos we watched about the bats today:

Gerry gives an overview of vampire bats: https://www.youtube.com/watch?v=pk2brNQxQxY

Video of two vampire bats feeding on a cow at night: https://www.youtube.com/watch?v=lJDq9yjWXSk


# More information

**For more information about vampire bat sociality, cooperation, relationship formation, and foraging, see: https://socialbat.org/papers/ 

For papers on specific topics, see the suggestions below:

Social foraging: https://journals.plos.org/plosbiology/article?id=10.1371/journal.pbio.3001366 

Relationship formation & social bet-hedging: https://doi.org/10.1098/rsbl.2017.0112 





########### 
# Start here to run the code!
########### 

Load all packages: This section loads all necessary packages (and installs them if necessary). We also load the landmarks data and do some processing to it (split by landmark type cow vs roost, which we'll use for plotting later), and view the data.
```{r}
if (!require("pacman")) install.packages("pacman")
pacman::p_load(trajr, tidyverse, gridExtra, igraph, scales, stringr, grid, rmarkdown)

#load landmark locations
landmarks <- read_csv("landmark_locations.csv") #this is a provided file

```

## **Q1: Importing data
**What is the text "#load landmark locations" on line 118? Why is it green?**
```
ADD YOUR ANSWER HERE
```


View all landmarks: Now that we have loaded the landmarks data using the code chunk above, we can view it. This table shows the landmark types (tree or cow), the unique identification of each landmark, the x location, the y location, and the color (we'll use this for plotting later). This code chunk also splits up the landmark types into two separate dataframes: one for roosts only (using subset on the whole landmarks dataframe, this keeps just the rows where the landmark column is "tree") and one for just the locations of the cows. We'll use this for plotting later.
```{r}
rmarkdown::paged_table(landmarks, options = NULL)

#divide landmarks by type and create two new dataframes, named "locs.roosts" and "locs.cows"
locs.roosts <- subset(landmarks, landmark=="tree")
locs.cows <- subset(landmarks, landmark=="cow")
```

## **Q2: Landmarks
**How many roost landmarks are there? How many cows?**
```
ADD YOUR ANSWER HERE
```

########### 
# PART 1: EXPLORE
########### 

In this section, you will analyze your data for the first time you play the "random movement" version of the bat game. In the first play of the game, your goal is to explore the habitat. We'll then compare your movements with the rest of the bats.

Play the game, then save your data as "explore.csv"


## Load, process, & view the data

The function "read_csv" is what we'll use to import and activate your data. You should see this file to the right of your screen in your file list. Make sure that the file name is exactly "explore" and saved as a .csv file. Any differences in spelling or capitalization will cause an error in importing your data.

```{r setup, warning=FALSE, class.output="scroll-250"}
explore.locs <- read_csv("explore.csv") #this is uploaded by the students

#this is backup data in case student data won't run (just delete the "#" from the start of the line below)
#explore.locs <- read_csv("example_explore.csv") 


#rename columns
colnames(explore.locs) <- c("times", "agent", "x", "y")

#rename bat IDs in raw data, make bat -1 the "Player"
explore.locs$batID <- ifelse(explore.locs$agent==-1, "Player", paste("Bat", formatC(explore.locs$agent, width=2, flag="0"), sep=" "))

```

## **Q3: Importing data
**Which line of code imports the data? Write the line number below**
```
ADD YOUR ANSWER HERE
```

The code above imported your explore data  as a "dataframe" which is similar to a table or a spreadsheet in excel. Dataframes are one type of data structure that R uses to store information.

The table below shows the data for the exploratory phase of the game in 5 columns.
```{r}
rmarkdown::paged_table(explore.locs, options = NULL)
```

## **Q4: What are the names of the 5 columns in the explore.locs dataframe?
```
ADD YOUR ANSWER HERE
```

## Plot all the trajectories
This block of code plots the movement trajectories for each bat, with each bat's movements appearing in its own panel. This plot code uses the landmark data we imported above, and then split by landmark type, to plot two kinds of landmarks.
```{r fig0, fig.height = 8, fig.width = 8, fig.cap="Figure 1: Plot of all bat trajectories. for exploratory phase"}

ggplot(explore.locs, aes(x, y, group=1)) +
  #add cows and roosts first so trajectories plot over them
  geom_point(data=locs.cows, aes(x=x, y=y), colour="darkgrey", size=3, pch=16) +
  geom_point(data=locs.roosts, aes(x=x, y=y), colour="green", size=3, pch=18) +
  #add trajectories
  geom_path() +
  #scale_y_reverse() +
  xlim(0,50) +
  ylim(50,0) +
  labs(title = "Bat trajectories: random movement (explore)",
       subtitle = "Trajectories=black, roost locations=green, cow locations=grey") +
  #set theme for plots
  theme(aspect.ratio=1,
        panel.background = element_blank(),
        panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(),
        axis.line = element_line(colour = "black"),
        panel.border = element_rect(colour = "black", fill=NA, linewidth=0.5),
        legend.position="bottom", legend.direction="horizontal") +
  #facet wrap to show one trajectory per bat
  facet_wrap(~ batID,ncol = 4)
```

## **Q5: Plotting landmarks

**Which landmarks are plotted in the code chunk above?** 
```
ADD YOUR ANSWER HERE
```

**What are the names of the two dataframes that were used to plot the landmarks?**
```
ADD YOUR ANSWER HERE
```

**What colors were used to plot each?**
```
ADD YOUR ANSWER HERE
```

########### 
# PART 2: RANDOM MOVEMENTS
########### 
In this section, you will analyze your data for the second time you play the "random movement" version of the bat game. All the programmed "Non-Player Character" bats (NPCs) are programmed to move randomly. At each timestep, they choose a direction to move and move one step in that direction. 

In the second play of the game, your goal is to try to act like all the other bats and randomly move around the habitat. We'll then compare your movements with the rest of the bats to see if you were successful in following random movements.

Play the game, then save your data as "random.csv"


## Load, process, & view the data

Load data & process
```{r}
rand.locs <- read_csv("random.csv") #this is uploaded by the students

#this is backup data in case student data won't run (just delete the "#" from the start of the line below)
#rand.locs <- read_csv("example_random.csv") 


#rename cols
colnames(rand.locs) <- c("times", "agent", "x", "y")

#rename bat IDs in raw data, make bat -1 the "Player"
rand.locs$batID <- ifelse(rand.locs$agent==-1, "Player", paste("Bat", formatC(rand.locs$agent, width=2, flag="0"), sep=" "))

```


This table shows the data for the random phase of the game in 5 columns: timestep (starting at 1), the ID number of each bat ("agent"), the x location, the y location, and the name of each bat ("batID").
```{r}
rmarkdown::paged_table(rand.locs, options = NULL)
```


## Plot all the trajectories
```{r fig1, fig.height = 8, fig.width = 8, fig.cap="Figure: Plot of all bat trajectories (with the goal of producing random movements)."}

ggplot(rand.locs, aes(x, y, group=1)) +
  #add cows and roosts first so trajectories plot over them
  geom_point(data=locs.cows, aes(x=x, y=y), colour="darkgrey", size=3, pch=16) +
  geom_point(data=locs.roosts, aes(x=x, y=y), colour="green", size=3, pch=18) +
  #add trajectories
  geom_path() +
  #scale_y_reverse() +
  xlim(0,50) +
  ylim(50,0) +
  labs(title = "Bat trajectories: random movement",
       subtitle = "Trajectories=black, roost locations=green, cow locations=grey") +
  #set theme for plots
  theme(aspect.ratio=1,
        panel.background = element_blank(),
        panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(),
        axis.line = element_line(colour = "black"),
        panel.border = element_rect(colour = "black", fill=NA, linewidth=0.5),
        legend.position="bottom", legend.direction="horizontal") +
  #facet wrap to show one trajectory per bat
  facet_wrap(~ batID,ncol = 4)
```


## ** Q6: Compare your trajectory to the NPC bats
**Humans often have a lot of trouble behaving randomly. How does your trajectory ("Player" panel) compare to the NPC bats? What were some major differences between your movements and the NPC bats that were programmed to moved randomly? Did you have a strategy for behaving randomly - and if so, did it work at all?**

```
ADD YOUR ANSWER HERE

```



## Analyze the trajectories
To analyze aspects of the trajectories, we will make an empty dataframe called "trajectory.summary" and use the code below to fill it in. We'll use a loop to do this. The loop runs once for each bat in the dataset: for each bat, the loop calculates the distance each bat traveled, the straightness of their movement path, and the mean number of direction changes they used in their movements.

Loop to summarize trajectories measures for each bat
```{r}
#make empty dataframe to write trajectory summaries to
trajectory.summary <- data.frame(batID=character(),
                                 distance=double(),
                                 straightness=double(),
                                 sinosoidy=double(),
                                 mean.dirchange=double())
# LOOP

# loop map: vector of animal ids
ids <- unique(rand.locs$batID)

for (bat in 1:length(ids)) { #bat=1
  #filter data for just focal bat
  loop.bat <- ids[bat]
  loop.data <- subset(rand.locs, batID==loop.bat)
  
  #format & sort data
  loop.data <- loop.data %>% 
    select(x, y, times) %>% #select just columns needed
    arrange(times)
  
  #make trajectory & summarize
  trj <- trajr::TrajFromCoords(loop.data)
  distance        <- trajr::TrajDistance(trj)
  straightness    <- trajr::TrajStraightness(trj)
  mean.dirchange  <- mean(trajr::TrajDirectionalChange(trj))
  batID           <- loop.bat
  
  #compile data & write
  loop.compiled <- cbind.data.frame(batID, 
                                    distance, 
                                    straightness, 
                                    mean.dirchange)
  
  trajectory.summary <- rbind.data.frame(trajectory.summary, loop.compiled)
  
}
```

View data structure
```{r}
rmarkdown::paged_table(trajectory.summary, options = NULL)
```

## ** Q7: Trajectory summaries
**What are the names of the columns in the trajectory.summary dataframe?**
```
ADD YOUR ANSWER HERE

```

Format the trajectory data: in this section we'll split the data into just data from the NPC bats (dataframe "NPCs") and just data from the player (dataframe "player"). We'll use this for plotting below.
```{r}
#melt summaries & separate NPCs and Player summary data
melted_traj.summs <- pivot_longer(trajectory.summary, !batID, names_to = "type.mm", values_to = "value")

NPCs <- subset(melted_traj.summs, batID!="Player")
player <- subset(melted_traj.summs, batID=="Player")
```


Plot the trajectory data: we'll plot each measure separately and then combine all of them into a multi-panel plot where we can compare all the measures side by side. These plots all show the NPC data with raw points shown in brown circles and the summary of the variability in the NPC data shown as a boxplot. For an overview of boxplots, visit https://www.rforecology.com/post/2022-04-06-how-to-make-a-boxplot-in-r/ and read the section "Boxplot Components". Generally, any points that are higher or lower than the highest and lowest ends of the "whiskers" of the box plot are considered "unusual" and are treated as outliers. For our purposes, you'll want to compare where your data (Player, in red) falls compared to the NPC bats, who are all plotted in red.
```{r fig2, fig.height = 5, fig.width = 8, fig.cap="Figure: Plot of summary measures of random movements when player goal is to also move randomly."}
#distance
player.dist <- player$value[player$type.mm=="distance"]
dist <- ggplot(NPCs[NPCs$type.mm=="distance",], aes(type.mm, value)) +
  geom_boxplot(color="saddlebrown", fill="saddlebrown", alpha=0.2, outlier.shape = NA) +
  geom_jitter(width = 0.3, size=5, pch=21, col="white", bg="saddlebrown") +
  ylim(0,max(c(NPCs$value[NPCs$type.mm=="distance"]),player$value[player$type.mm=="distance"])) +
  ggtitle("Distance") + 
  ylab("Distance") +
  geom_point(aes(y=player.dist), col="black", bg="red", size=5, pch=23) +
  theme(plot.title = element_text(hjust = 0.5),
        axis.title.x=element_blank(),
        axis.text.x=element_blank(),
        axis.ticks.x=element_blank(),
        panel.background = element_blank(),
        panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(),
        axis.line = element_line(colour = "black"),
        panel.border = element_rect(colour = "black", fill=NA, linewidth=0.5))


#straightness
player.straightn <- player$value[player$type.mm=="straightness"]
straightness <- ggplot(NPCs[NPCs$type.mm=="straightness",], aes(type.mm, value)) +
  geom_boxplot(color="saddlebrown", fill="saddlebrown", alpha=0.2, outlier.shape = NA) +
  geom_jitter(width = 0.3, size=5, pch=21, col="white", bg="saddlebrown") +
  ylim(0,max(c(NPCs$value[NPCs$type.mm=="straightness"]),player$value[player$type.mm=="straightness"])) +
  ggtitle("Straightness") + 
  ylab("Straightness") +
  geom_point(aes(y=player.straightn), col="black", bg="red", size=5, pch=23) +
  theme(plot.title = element_text(hjust = 0.5),
        axis.title.x=element_blank(),
        axis.text.x=element_blank(),
        axis.ticks.x=element_blank(),
        panel.background = element_blank(),
        panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(),
        axis.line = element_line(colour = "black"),
        panel.border = element_rect(colour = "black", fill=NA, linewidth=0.5))


#direction change
player.dirchange <- player$value[player$type.mm=="mean.dirchange"]
dirchange <- ggplot(NPCs[NPCs$type.mm=="mean.dirchange",], aes(type.mm, value)) +
  geom_boxplot(color="saddlebrown", fill="saddlebrown", alpha=0.2, outlier.shape = NA) +
  geom_jitter(width = 0.3, size=5, pch=21, col="white", bg="saddlebrown") +
  ylim(0,max(c(NPCs$value[NPCs$type.mm=="mean.dirchange"]),player$value[player$type.mm=="mean.dirchange"])) +
  ggtitle("Direction change") + 
  ylab("Mean direction change") +
  geom_point(aes(y=player.dirchange), col="black", bg="red", size=5, pch=23) +
  theme(plot.title = element_text(hjust = 0.5),
        axis.title.x=element_blank(),
        axis.text.x=element_blank(),
        axis.ticks.x=element_blank(),
        panel.background = element_blank(),
        panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(),
        axis.line = element_line(colour = "black"),
        panel.border = element_rect(colour = "black", fill=NA, linewidth=0.5))


# plot all together to compare
gridExtra::grid.arrange(dist, straightness, dirchange, ncol=4,
                        top=textGrob("Bat trajectories: random movement"))

```

## ** Q8: Compare your movements to the NPC bats
**How does the summary of your movements ("Player" points, in red) compare to the NPC bats? For each of the three measures, write whether you were an outlier or not, and whether your value was higher or lower than the values for the NPC bats** 
```
ADD YOUR ANSWER HERE

```

**Are you acting "normally" in this social world, compared to the programmed bats?**
```
ADD YOUR ANSWER HERE

```


## Use location data to find distances between bats and landmarks

The code chunk below is what we'll use to figure out how far each bat is from each landmark. We'll quantify these distances every 10 seconds. We'll use a distance threshold to determine whether bats are "near" or "not near" each landmark at each time period. In the code below, we count a bat as "near" a landmark if the bat is 5 units or less distance away from the landmark. The code keeps data for any time any bat is recorded as "near" a landmark and gets rid of all the times bats were not near a particular landmark. 
```{r}

   ts <- seq(0,750)
    ev10steps <- ts[(ts %% 10) == 0]
    ev10steps <- ev10steps[2:length(ev10steps)]
    
    
   #clean landmarks
    landmarks.tr <- subset(landmarks, select=c(landmark, landmarkID, x, y))
    colnames(landmarks.tr) <- c("landmark", "landmarkID", "land.x", "land.y")  
    
    #make an empty dataframe to write to
    distance_landmarks <- data.frame(times=integer(),
                                     batID=character(),
                                     landmark=character(),
                                     landmarkID=character(),
                                     dist.class=character())
    
    #Loop over all bat locations to find distances between each bat and each landmark
    for (step in 2:length(ev10steps)) { #step=1
      loop.step <- ev10steps[step]
      
      #if no data at that timestep, skip
      loop.data <- if(nrow(subset(rand.locs, times==loop.step))<1) next #skip if no data at this ts
      
      #otherwise, subset the data
      loop.data <- subset(rand.locs, times==loop.step)
      
      #find distance from bats to all landmarks
      landmark.combos <- merge(loop.data, landmarks.tr)
      landmark.combos <- landmark.combos %>% mutate(dist=sqrt((x-land.x)^2 + (y-land.y)^2))
      #set categories of "near" or "not near" based on distance between bat and the landmark ("near" has to be 5 units or closer)
      landmark.combos$dist.class <- ifelse(landmark.combos$dist<=5, "near", "not.near") 
      
      #if no landmarks are near, skip to the next timestep
      if(nrow(subset(landmark.combos, dist.class=="near"))<1) next #skip if no bats are near
      
      #if any landmarks are near, subset the data
      landmark.combos.sub <- subset(landmark.combos, dist.class=="near")
      landmark.combos.subtr <- subset(landmark.combos.sub, select=c(times, batID, landmark, landmarkID, dist.class))
      
      
      #write data to save
      distance_landmarks <- rbind.data.frame(distance_landmarks, landmark.combos.subtr)
      
    }

```


## **Q9: Distance to landmarks
**Find the line of code in the chunk above that determines whether each bat is near or not near each landmark. What is the 6-letter function name that appears just to the right of the arrow (<-) on that line? What do you think this line of code is doing?** 
```
ADD YOUR ANSWER HERE

```

## Summarize proximity to landmarks
In this section, we'll summarize how often each bat was near each landmark, and how many unique cows each bat visited. We'll also calculate the mean number of cows founds across all the bats.
```{r}
#summarize how many times each bat was near a roost or cow, and how many of each it visited
summ_landmarks <- distance_landmarks %>% group_by(batID, landmark, landmarkID) %>%
  summarize(times.near=n())

unique.landmarks <- summ_landmarks %>% group_by(batID, landmark) %>% summarize(unique.visitsXtype=n())
unique.landmarks_cows <- subset(unique.landmarks, landmark=="cow")

all.bats <- as.data.frame(unique(rand.locs$batID))
colnames(all.bats) <- "batID"

unique.landmarks_cows <- merge(all.bats, unique.landmarks_cows, by="batID", all.x=TRUE, fill=0)
unique.landmarks_cows$unique.visitsXtype[is.na(unique.landmarks_cows$unique.visitsXtype)] <- 0

rmarkdown::paged_table(unique.landmarks_cows, options = NULL)

mean.NPC.cows <- mean(unique.landmarks_cows$unique.visitsXtype[unique.landmarks_cows$batID!="Player"])
n.player.cows <-unique.landmarks_cows$unique.visitsXtype[unique.landmarks_cows$batID=="Player"]
```

## Plot number of cows each bat found
```{r,fig.cap="Figure: Plot of the number of cows discovered by each bat when movements are random."}
#plot number of cows discovered
ggplot(unique.landmarks_cows, aes(x=batID, y=unique.visitsXtype, 
                                  fill = ifelse(batID == "Player", "Player", "NPC bats"))) +
  geom_bar(stat="identity") +
  labs(x="Bats", 
       y="Number of cows found", 
       title = "Bat trajectories: random movement") +
  ## add manual color scale
  scale_fill_manual("legend",         ###### in this call: colour change
                    values = c("Player" = "red", "NPC bats" = "saddlebrown")) +
  theme(plot.title = element_text(hjust = 0.5),
        panel.grid.major.y = element_line(color = "grey",
                                          linewidth = 0.5,
                                          linetype = 1),
        axis.line = element_line(colour = "black"),
        panel.border = element_rect(colour = "black", fill=NA, linewidth=0.5),
        legend.position="bottom",
        axis.text.x=element_text(angle = 90, vjust = 0.5, hjust=1)) +
  annotate("text", x=1, y=7, hjust = 0,
           label= paste0("Mean number cows found by NPC bats = ", round(mean.NPC.cows,2))) +
  annotate("text", x=1, y=6.5, hjust = 0,
           label= paste0("Number cows found by player = ", n.player.cows))
```


## ** Q10: Random movement foraging success **

**How many cows did you visit while foraging?**
```
ADD YOUR ANSWER HERE

```

**Did any other bats find cows? (yes or no)**
```
ADD YOUR ANSWER HERE

```

**Which other bats were successful foragers and how many cows did they find?**  
```
ADD YOUR ANSWER HERE

```

**Is moving randomly around the habitat a successful foraging strategy that you'd expect real bats to use? Why or why not?**
```
ADD YOUR ANSWER HERE

```


########### 
# PART 3: SOCIAL FORAGING 
############
When you played the first two versions of the random movements game, all the NPC bats were programmed to just move randomly around the habitat, without responding to anything in the habitat. Real bats are unlikely to move absolutely randomly around their habitat -- as you noticed in the explore and random games, moving randomly makes it so almost none of the bats actually find a cow. This would be a terrible strategy for a real bat to use because they would be very likely to starve and die. Real bats use a suite of rules to find food, but also to stick with other bats that they have strong relationships with.

For an overview, watch this video of Gerry explaining how they study bats in the wild: https://www.youtube.com/watch?v=BeAiUBM18Cs&t=248s

We are now going to play another version of the game. You'll now choose "Social Foraging" as the movement type (https://eahobson.github.io). In the "Social Foraging" version of the game, the NPC bats have new rules that they use to structure their movements. Each NPC bat is assigned a "buddy". 

**NPC bats now have two goals:** they need to find cows to forage on, but they also prefer to forage with their assigned buddy. 

In this game, activate the game and wait 10 seconds. Watch how the bats start to move around the habitat. Use this time to pick one bat to be your "buddy". Once the 10 seconds have passed, you will use the same rules that the NPC bats use: your goal is to move around and find cows to feed on, but you also need to stay close to the bat you've chosen as your buddy.

Play the game, then save your data as "socforag.csv"


# Load, process, & view the data

Load data & process
```{r warning=FALSE}
socfor.locs <- read_csv("socforag.csv") #this is uploaded by the students #SOCFORG.csv

#this is backup data in case student data won't run (just delete the "#" from the start of the line below)
#socfor.locs <- read_csv("example_socforag.csv") 

#rename cols
colnames(socfor.locs) <- c("times", "agent", "x", "y")

#rename bat IDs in raw data, make bat -1 the "Player"
socfor.locs$batID <- ifelse(socfor.locs$agent==-1, "Player", paste("Bat", formatC(socfor.locs$agent, width=2, flag="0"), sep=" "))

```


View the game data
```{r}
rmarkdown::paged_table(socfor.locs, options = NULL)

```

# Plot all the trajectories 
```{r fig6, fig.height = 10, fig.width = 8, fig.cap="Figure: Plot of all bat trajectories (social foraging)."}

ggplot(socfor.locs, aes(x, y, group=1)) +
  #add cows and roosts first so trajectories plot over them
  geom_point(data=locs.cows, aes(x=x, y=y), colour="darkgrey", size=3, pch=16) +
  geom_point(data=locs.roosts, aes(x=x, y=y), colour="green", size=3, pch=18) +
  #add trajectories
  geom_path() +
  #scale_y_reverse() +
  xlim(0,50) +
  ylim(50,0) +
  labs(title = "Bat trajectories: social foraging",
       subtitle = "Trajectories=black, roost locations=green, cow locations=grey") +
  #set theme for plots
  theme(aspect.ratio=1,
        panel.background = element_blank(),
        panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(),
        axis.line = element_line(colour = "black"),
        panel.border = element_rect(colour = "black", fill=NA, linewidth=0.5),
        legend.position="bottom", legend.direction="horizontal") +
  #facet wrap to show one trajectory per bat
  facet_wrap(~ batID,ncol = 4)
```

## ** Q11: Compare your trajectory to the NPC bats **
**Now that you are not trying to move randomly, how does your trajectory compare to the NPC bats? Is it similar or different?**

```
ADD YOUR ANSWER HERE

```


## Analyze trajectories

Summarize all trajectories: we'll use the same method we used earlier to measure three aspects of your trajectories, and those of the other bats: distance, staightness of the path, and the mean number of direction changes.
```{r}
#make empty dataframe to write trajectory summaries to
trajectory.summary <- data.frame(batID=character(),
                                 distance=double(),
                                 straightness=double(),
                                 sinosoidy=double(),
                                 mean.dirchange=double())
# LOOP

# loop map: vector of animal ids
ids <- unique(socfor.locs$batID)

for (bat in 1:length(ids)) { #bat=1
  #filter data for just focal bat
  loop.bat <- ids[bat]
  loop.data <- subset(socfor.locs, batID==loop.bat)
  
  #format & sort data
  loop.data <- loop.data %>% 
    select(x, y, times) %>% #select just columns needed
    arrange(times)
  
  #make trajectory & summarize
  trj <- trajr::TrajFromCoords(loop.data)
  #plot(trj)
  distance        <- trajr::TrajDistance(trj)
  straightness    <- trajr::TrajStraightness(trj)
  sinosoidy       <- trajr::TrajSinuosity2(trj)
  mean.dirchange  <- mean(trajr::TrajDirectionalChange(trj))
  batID           <- loop.bat
  
  #compile data & write
  loop.compiled <- cbind.data.frame(batID, 
                                    distance, 
                                    straightness, 
                                    sinosoidy, 
                                    mean.dirchange)
  
  trajectory.summary <- rbind.data.frame(trajectory.summary, loop.compiled)
  
}
```

View data structure
```{r}
rmarkdown::paged_table(trajectory.summary, options = NULL)

```


Format the trajectory data
```{r}
#melt summaries & separate NPCs and Player summary data
melted_traj.summs <- pivot_longer(trajectory.summary, !batID, names_to = "type.mm", values_to = "value")

NPCs <- subset(melted_traj.summs, batID!="Player")
player <- subset(melted_traj.summs, batID=="Player")
```

Plot the trajectory data
```{r fig7, fig.height = 5, fig.width = 10}
#distance
player.dist <- player$value[player$type.mm=="distance"]
dist <- ggplot(NPCs[NPCs$type.mm=="distance",], aes(type.mm, value)) +
  geom_boxplot(color="saddlebrown", fill="saddlebrown", alpha=0.2, outlier.shape = NA) +
  geom_jitter(width = 0.3, size=5, pch=21, col="white", bg="saddlebrown") +
  ylim(0,max(c(NPCs$value[NPCs$type.mm=="distance"]),player$value[player$type.mm=="distance"])) +
  ggtitle("Distance") + 
  ylab("Distance") +
  geom_point(aes(y=player.dist), col="black", bg="red", size=5, pch=23) +
  theme(plot.title = element_text(hjust = 0.5),
        axis.title.x=element_blank(),
        axis.text.x=element_blank(),
        axis.ticks.x=element_blank(),
        panel.background = element_blank(),
        panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(),
        axis.line = element_line(colour = "black"),
        panel.border = element_rect(colour = "black", fill=NA, linewidth=0.5))


#straightness
player.straightn <- player$value[player$type.mm=="straightness"]
straightness <- ggplot(NPCs[NPCs$type.mm=="straightness",], aes(type.mm, value)) +
  geom_boxplot(color="saddlebrown", fill="saddlebrown", alpha=0.2, outlier.shape = NA) +
  geom_jitter(width = 0.3, size=5, pch=21, col="white", bg="saddlebrown") +
  ylim(0,max(c(NPCs$value[NPCs$type.mm=="straightness"]),player$value[player$type.mm=="straightness"])) +
  ggtitle("Straightness") + 
  ylab("Straightness") +
  geom_point(aes(y=player.straightn), col="black", bg="red", size=5, pch=23) +
  theme(plot.title = element_text(hjust = 0.5),
        axis.title.x=element_blank(),
        axis.text.x=element_blank(),
        axis.ticks.x=element_blank(),
        panel.background = element_blank(),
        panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(),
        axis.line = element_line(colour = "black"),
        panel.border = element_rect(colour = "black", fill=NA, linewidth=0.5))


#direction change
player.dirchange <- player$value[player$type.mm=="mean.dirchange"]
dirchange <- ggplot(NPCs[NPCs$type.mm=="mean.dirchange",], aes(type.mm, value)) +
  geom_boxplot(color="saddlebrown", fill="saddlebrown", alpha=0.2, outlier.shape = NA) +
  geom_jitter(width = 0.3, size=5, pch=21, col="white", bg="saddlebrown") +
  ylim(0,max(c(NPCs$value[NPCs$type.mm=="mean.dirchange"]),player$value[player$type.mm=="mean.dirchange"])) +
  ggtitle("Direction change") + 
  ylab("Mean direction change") +
  geom_point(aes(y=player.dirchange), col="black", bg="red", size=5, pch=23) +
  theme(plot.title = element_text(hjust = 0.5),
        axis.title.x=element_blank(),
        axis.text.x=element_blank(),
        axis.ticks.x=element_blank(),
        panel.background = element_blank(),
        panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(),
        axis.line = element_line(colour = "black"),
        panel.border = element_rect(colour = "black", fill=NA, linewidth=0.5))


# plot all together to compare
gridExtra::grid.arrange(dist, straightness, dirchange, ncol=4,
                        top=textGrob("Bat trajectories: social foraging"))

```


## ** Q12: Compare your movement summaries to the NPC bats **
**Now that you are not trying to move randomly, how do your movements compare to the NPC bats? How does the summary of your movements ("Player" points, in red) compare to the NPC bats? What aspects of your movements were similar or different compared to the programmed bats? For each measure, was your pattern higher or lower than the programmed bats?**  
```
ADD YOUR ANSWER HERE

```

**Are you acting "normally" in this social world, compared to the programmed bats? Were you successful at following the rules of the group, in ways that were similar to how the NPC bats were behaving?**

```
ADD YOUR ANSWER HERE

```


# Find distances between bats and landmarks

Use the locations to find the distances between each bat and all landmarks at each time step. We'll use a 5-unit threshold for categorizing observations as "near", just like we did earlier.
```{r}

   ts <- seq(0,750)
    ev10steps <- ts[(ts %% 10) == 0]
    ev10steps <- ev10steps[2:length(ev10steps)]
    
    
   #clean landmarks
    landmarks.tr <- subset(landmarks, select=c(landmark, landmarkID, x, y))
    colnames(landmarks.tr) <- c("landmark", "landmarkID", "land.x", "land.y")  
    
    #make an empty dataframe to write to
    distance_landmarks <- data.frame(times=integer(),
                                     batID=character(),
                                     landmark=character(),
                                     landmarkID=character(),
                                     dist.class=character())
    
    #Loop over all bat locations to find distances between each bat and each landmark
    for (step in 2:length(ev10steps)) { #step=1
      loop.step <- ev10steps[step]
      
      #if no data at that timestep, skip
      loop.data <- if(nrow(subset(socfor.locs, times==loop.step))<1) next #skip if no data at this ts
      
      #otherwise, subset the data
      loop.data <- subset(socfor.locs, times==loop.step)
      
      #find distance from bats to all landmarks
      landmark.combos <- merge(loop.data, landmarks.tr)
      landmark.combos <- landmark.combos %>% mutate(dist=sqrt((x-land.x)^2 + (y-land.y)^2))
      #set categories of "near" or "not near" based on distance to them
      landmark.combos$dist.class <- ifelse(landmark.combos$dist<=5, "near", "not.near")
      
      #if no landmarks are near, skip to the next timestep
      if(nrow(subset(landmark.combos, dist.class=="near"))<1) next #skip if no bats are near
      
      #if any landmarks are near, subset the data
      landmark.combos.sub <- subset(landmark.combos, dist.class=="near")
      landmark.combos.subtr <- subset(landmark.combos.sub, select=c(times, batID, landmark, landmarkID, dist.class))
      
      
      #write data to save
      distance_landmarks <- rbind.data.frame(distance_landmarks, landmark.combos.subtr)
      
    }
    
#View results
rmarkdown::paged_table(distance_landmarks, options = NULL)


```

## Summarize proximity to landmarks

```{r}
#summarize how many times each bat was near a roost or cow, and how many of each it visited
summ_landmarks <- distance_landmarks %>% group_by(batID, landmark, landmarkID) %>%
  summarize(times.near=n())

unique.landmarks <- summ_landmarks %>% group_by(batID, landmark) %>% summarize(unique.visitsXtype=n())
unique.landmarks_cows <- subset(unique.landmarks, landmark=="cow")

all.bats <- as.data.frame(unique(socfor.locs$batID))
colnames(all.bats) <- "batID"

unique.landmarks_cows <- merge(all.bats, unique.landmarks_cows, by="batID", all.x=TRUE, fill=0)
unique.landmarks_cows$unique.visitsXtype[is.na(unique.landmarks_cows$unique.visitsXtype)] <- 0

mean.NPC.cows <- mean(unique.landmarks_cows$unique.visitsXtype[unique.landmarks_cows$batID!="Player"])
n.player.cows <-unique.landmarks_cows$unique.visitsXtype[unique.landmarks_cows$batID=="Player"]
```

## Plot number of cows each bat found
```{r}
#plot number of cows discovered
ggplot(unique.landmarks_cows, aes(x=batID, y=unique.visitsXtype, 
                                  fill = ifelse(batID == "Player", "Player", "NPC bats"))) +
  geom_bar(stat="identity") +
  labs(x="Bats", 
       y="Number of cows found", 
       title = "Bat trajectories: social foraging") +
  ## add manual color scale
  scale_fill_manual("legend",         ###### in this call: colour change
                    values = c("Player" = "red", "NPC bats" = "saddlebrown")) +
  theme(plot.title = element_text(hjust = 0.5),
        panel.grid.major.y = element_line(color = "grey",
                                          linewidth = 0.5,
                                          linetype = 1),
        axis.line = element_line(colour = "black"),
        panel.border = element_rect(colour = "black", fill=NA, linewidth=0.5),
        legend.position="bottom",
        axis.text.x=element_text(angle = 90, vjust = 0.5, hjust=1)) +
  annotate("text", x=1, y=7, hjust = 0,
           label= paste0("Mean number cows found by NPC bats = ", round(mean.NPC.cows,2))) +
  annotate("text", x=1, y=6.5, hjust = 0,
           label= paste0("Number cows found by player = ", n.player.cows))
```

## ** Q13: Social foraging success

**How many cows did you visit while foraging?**  
```
ADD YOUR ANSWER HERE

```

**Did any other bats find cows?**
```
ADD YOUR ANSWER HERE

```

**Which other bats were successful foragers and how many cows did they find?**  
```
ADD YOUR ANSWER HERE

```
**Is social foraging potentially a successful foraging strategy that you'd expect real bats to use? Why or why not?**
```
ADD YOUR ANSWER HERE

```

# Use location data to find distances between all bats
Similarly to how we found the distances between each bat and each landmark, we'll now calculate the distance from one bat to each other bat at each 10-second interval. We'll count bats as "near" each other if they are within 5 or less distance units from each other, just like we used for the landmarks earlier. We'll then use these summaries to build networks showing which bats were near each other.
```{r}
   #for each timestep expand.grid to find all id combos, delete same ids
    ts <- seq(0,750)
    ev10steps <- ts[(ts %% 10) == 0]
    ev10steps <- ev10steps[2:length(ev10steps)]
    

    distance_bats <- data.frame(time=integer(),
                                batA=character(),
                                batB=character(),
                                dist.class=character())
    
    
    for (step in 1:length(ev10steps)) { #step=41
      loop.step <- ev10steps[step]
      #if no data at that timestep, skip
      loop.data <- if(nrow(subset(socfor.locs, times==loop.step))<1) next #skip if no data at this ts
      #otherwise, subset the data
      loop.data <- subset(socfor.locs, times==loop.step) 
      
      #find distance from each bat to each other bat
      loop.data$joiner <- 1
      all.combos <- merge(loop.data, loop.data, by="joiner")
      all.combos <- subset(all.combos, batID.x!=batID.y)
      all.combos <- all.combos %>% mutate(dist=sqrt((x.x-x.y)^2 + (y.x-y.y)^2))
      all.combos$dist.class <- ifelse(all.combos$dist<=5, "near", "not.near")
      
      #if no bats are near, skip to the next timestep
      all.combos.sub <- if(nrow(subset(all.combos, dist.class=="near"))<1) next #skip if no bats are near
      #if any bats are near, subset the data
      all.combos.sub <- subset(all.combos, dist.class=="near")
      
      all.combos.sub.tr <- subset(all.combos.sub, select=c(times.x, batID.x, batID.y, dist.class))
      colnames(all.combos.sub.tr) <- c("time", "batA", "batB", "dist.class")
      
      #write data to save
      distance_bats <- rbind.data.frame(distance_bats, all.combos.sub.tr)
      
    }

# view data structure
rmarkdown::paged_table(distance_bats, options = NULL)

```



# Summarize inter-bat proximities & compare network measures 

Now we'll quantify and plot the social networks for the bats in the social foraging game. These networks will summarize the proximity network, where we'll count the number of times each bat was observed as "near" other bats. The bats will be the "nodes" in the network (plotted as circles) and the proximity observations will be the "edges" (plotted as lines connecting the nodes). The width of each edge will represent how often those two bats were seen in close proximity to each other. Bats that are often seen close together will have wider edges connecting them, bats that are rarely observed close together will have narrow edges connecting them, and bats that are never seen together will not have a connection.

We'll used network metrics to quantify two social measures: "degree" and "strength". 

Degree quantifies how many others each individual is connected to in the network, and represents a count of the nodes each individual is directly connected to. Here, each bat's degree is the total number of other bats that it was ever recorded as "near". A bat with a degree of 3 was observed "near" 3 other bats.

Strength quantifies how often individuals are connected to others in the network and represents the sum of all the weights of the edges in the network.
```{r}
# set up attributes

all.bats <- as.data.frame(unique(socfor.locs$batID))
colnames(all.bats) <- "batID"

all.bats$node.type <- ifelse(all.bats$batID=="Player", "Player", "NPC Bat")
all.bats$node.color <- ifelse(all.bats$batID=="Player", "red", "saddlebrown")
all.bats$bat.name <- ifelse(all.bats$batID=="Player", "ME", str_sub(all.bats$batID, start= -2))

summary_social <- distance_bats %>% group_by(batA, batB) %>%
  summarize(n.near =n())

# view data structure
head(summary_social)


g <- graph_from_data_frame(summary_social, directed=FALSE) 
g
g <- as.undirected(g, mode="mutual")

# add attributes
V(g)$bat.name <- all.bats[match(V(g)$name, all.bats$batID), "bat.name"]
V(g)$node.color <- all.bats[match(V(g)$name, all.bats$batID), "node.color"]

de <- igraph::degree(g)/2
strength <- strength(g, weights=E(g)$n.near)/2

edge_density(g)

# How social is each bat?
# add summary for n bats near ("degree") and n times near any bat??? TKTK
network_summs <- data.frame(batID=V(g)$name, n.bats.near=de, times.near.others=strength)

# view data structure
rmarkdown::paged_table(network_summs, options = NULL)
```

## Plot network summaries
```{r}
NPCs.netsum <- subset(network_summs, batID!="Player")
player.netsum <- subset(network_summs, batID=="Player")


#degree
player_degree <- player.netsum$n.bats.near
plot_degree <- ggplot(NPCs.netsum, aes(5, n.bats.near)) +
  geom_boxplot(color="saddlebrown", fill="saddlebrown", alpha=0.2, outlier.shape = NA) +
  geom_jitter(width = 0.3, size=5, pch=21, col="white", bg="saddlebrown") +
  ylim(0,max(c(NPCs.netsum$n.bats.near,player.netsum$n.bats.near))) +
  ggtitle("Network degree") + 
  ylab("Number of unique bats encountered") +
  geom_point(aes(y=player_degree, x=5), col="black", bg="red", size=5, pch=23) +
  #  geom_point(aes(y=player.dirchange), col="black", bg="red", size=5, pch=23) +
  
  theme(plot.title = element_text(hjust = 0.5),
        axis.title.x=element_blank(),
        axis.text.x=element_blank(),
        axis.ticks.x=element_blank(),
        panel.background = element_blank(),
        panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(),
        axis.line = element_line(colour = "black"),
        panel.border = element_rect(colour = "black", fill=NA, linewidth=0.5))

#strength
player_strength <- player.netsum$times.near.others
plot_strength <- ggplot(NPCs.netsum, aes(5, times.near.others)) +
  geom_boxplot(color="saddlebrown", fill="saddlebrown", alpha=0.2, outlier.shape = NA) +
  geom_jitter(width = 0.3, size=5, pch=21, col="white", bg="saddlebrown") +
  ylim(0,max(c(NPCs.netsum$times.near.others,player.netsum$times.near.others))) +
  ggtitle("Network strength") + 
  ylab("Number encounters with other bats") +
  geom_point(aes(y=player_strength, x=5), col="black", bg="red", size=5, pch=23) +
  #  geom_point(aes(y=player.dirchange), col="black", bg="red", size=5, pch=23) +
  
  theme(plot.title = element_text(hjust = 0.5),
        axis.title.x=element_blank(),
        axis.text.x=element_blank(),
        axis.ticks.x=element_blank(),
        panel.background = element_blank(),
        panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(),
        axis.line = element_line(colour = "black"),
        panel.border = element_rect(colour = "black", fill=NA, linewidth=0.5))

# plot all together to compare
gridExtra::grid.arrange(plot_degree, plot_strength, ncol=2,
                        top=textGrob("Bat trajectories: social foraging"))
```

## ** Q14: Compare network metrics
**For social foraging, compare your social measures to the NPC bats. Were you behaving "normally" compared to the other bats? If not, how did your movements cause you to have different social measures than the NPC bats?**
```
ADD YOUR ANSWER HERE

```

## Plot proximity network
Plot bat-to-bat proximity network for all "near" events. In this plot, we'll summarize all the times each bat was ever near each other bat.
```{r fig9, fig.height = 8, fig.width = 8}
#Plot the network
set.seed(42)
plot(g, 
     edge.width=E(g)$n.near/3,
     edge.color=alpha("black", 0.4),
     main= "Social foraging proximity network (all near events)", 
     sub=paste0("Network density = ", round(edge_density(g),2)),
     vertex.size=17,
     vertex.color=V(g)$node.color,
     vertex.label.family="Arial Black",
     vertex.label.font=2,
     vertex.label.cex=0.75,
     vertex.label=V(g)$bat.name, 
     vertex.label.color="white",
     edge.curved=FALSE)

```


## ** Q15: Interpret full proximity network
**What do you notice about this network? Is it easy to tell which who each bat's buddies are?** 
```
ADD YOUR ANSWER HERE

```

**Why are there so many connections in the network? What does that tell you about how the bats are moving around in relation to each other?**
```
ADD YOUR ANSWER HERE

```


## Plot the proximity network without rare connections

Now we are going to remove some of the rarer proximity observations. This is often called "thresholding" in network analysis. We'll use a threshold of 10: the code below deletes any connections between bats who were "near" each other less than 10 times during the game. This approach can make it easier to see which bats often are in proximity.

We'll then plot this bat-to-bat proximity network with these rarer proximity connections removed.

```{r fig9b, fig.height = 8, fig.width = 8}

g2 <- delete.edges(g, which(E(g)$n.near <10))

#Plot the network
set.seed(42)
plot(g2, 
     edge.width=E(g2)$n.near/3,
     edge.color=alpha("black", 0.4),
     main= "Bat trajectories: social foraging", 
     #sub=paste0("Network density = ", round(edge_density(g),2)),
     vertex.size=17,
     vertex.color=V(g2)$node.color,
     vertex.label.family="Arial Black",
     vertex.label.font=2,
     vertex.label.cex=0.75,
     vertex.label=V(g2)$bat.name, 
     vertex.label.color="white",
     edge.curved=FALSE)

```

## ** Q16: Interpret thresholded proximity network
**What do you notice about this network? Is it easy to tell which who each bat's buddies are, compared to the full network?** 
```
ADD YOUR ANSWER HERE

```


# Find strongest-preferred bats & plot

Now we are going to find each bat's strongest partner - this is whichever bat each bat is most often scored as "near" in location.
```{r}
top.associate <- summary_social %>% group_by(batA) %>%
  filter(n.near == max(n.near)) %>%
  arrange(batA)

rmarkdown::paged_table(top.associate, options = NULL)

```

Plot strongest partners
```{r fig10, fig.height = 8, fig.width = 8}
#set max axes for better labeling
max.y <- max(top.associate$n.near)+6

#barplot most-preferred associates and how often each bat was near their preferred
top.assos <- ggplot(top.associate, aes(x=batB, y=n.near, group=1, fill = ifelse(batA == "Player", "Player", "NPC bats"))) +
  geom_bar(stat="identity") +
  geom_text(aes(label = stringr::str_wrap(batB, 3)), 
            vjust = -0.2, 
            colour = "black",
            size=3,
            fontface = "italic") +
  ylim(0,max.y) + #set y limits for nicer labels
  labs(title="Stongest-preferred associates", 
       subtitle= "Bat trajectories: social foraging",
       x="Bats", 
       y="Number observations near favorite") +
  ## add manual color scale
  scale_fill_manual("legend",  
                    values = c("Player" = "red", "NPC bats" = "saddlebrown")) +
  theme(plot.title = element_text(hjust = 0.5),
        panel.grid.major.y = element_line(color = "grey",
                                          linewidth = 0.5,
                                          linetype = 1),
        axis.line = element_line(colour = "black"),
        panel.border = element_rect(colour = "black", fill=NA, linewidth=0.5),
        legend.position="bottom",
        axis.text.x=element_text(angle = 90, vjust = 0.5, hjust=1),
        aspect.ratio=1) +
  facet_wrap(~ batA,ncol = 5)

top.assos
```

## ** Q17: Top associate
**Was your top associate the bat you chose as a buddy?** 
```
ADD YOUR ANSWER HERE

```

**Who was your buddy's top associate? Was it you or another bat?** 
```
ADD YOUR ANSWER HERE

```

## Compare two trajectories
To visualize how well you matched the movements of your closest associate (hopefully the "buddy" you chose!), we'll plot your trajectory in red and your closest associate's trajectory in brown. 

This code chunk processes the data and finds your "top associate":
```{r}
top.associate.player <- subset(top.associate, batA=="Player")

player.top.assoIDs <- top.associate.player$batB # make a vector of names of all the player's top associates

topasso.locs <- socfor.locs[socfor.locs$batID %in% player.top.assoIDs,] # subset the location data to only include player's top associate data

colnames(topasso.locs) <- c("times", "agent", "x", "y", "top.assoID")

unique(topasso.locs$batID) # check that it worked!

player.locs <- subset(socfor.locs, batID=="Player") # subset the location data to only include player's data
  
unique(player.locs$batID) # check that it worked!

```

This code chunk plots both trajectories: your path in red and your buddy's path in brown.
```{r fig11, fig.height = 8, fig.width = 8}

# test

under <- ggplot(player.locs, aes(x, y)) +
  geom_path(colour="red", linewidth=1.5, alpha=0.45) +
  xlim(0,50) +
  ylim(50,0) +
  labs(title = "Bat trajectories: social foraging, top associates of Player",
       subtitle = "Trajectories: Red=Player, Brown=Top associates; roost locations=green, cow locations=grey") +
  #set theme for plots
  theme(aspect.ratio=1,
        panel.background = element_blank(),
        panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(),
        axis.line = element_line(colour = "black"),
        panel.border = element_rect(colour = "black", fill=NA, linewidth=0.5),
        legend.position="bottom", legend.direction="horizontal") 

upper <- under + 
        geom_path(data=topasso.locs, aes(x=x, y=y, group=top.assoID), colour="saddlebrown", linewidth=1.0,) +
        #add cows and roosts first so they plot over trajectories
        geom_point(data=locs.cows, aes(x=x, y=y), colour="darkgrey", size=3, pch=16) +
        geom_point(data=locs.roosts, aes(x=x, y=y), colour="green", size=3, pch=18) +
        facet_wrap(~ top.assoID) 

upper
  
```


## **Q18: Path matching
**How well did your path match your buddy's path? Did you have any times where you did not match the path very closely?** 
```
ADD YOUR ANSWER HERE

```

########### 
# PART 4: BET-HEDGING
########### 
When you played the first two version of the social foraging game, you picked one bat to be your "buddy" and followed two rules: (1) visit the cows to forage, and (2) try to stick close to your buddy while foraging. In the real world, this strategy of having one very strong friend might be risky: if something happens to your one friend (gets sick, is predated, wanders off, etc.) and you desperately need some food sharing, you wouldn't have any other strong friendships to rely on. Real vampire bats appear to develop several strong friendships, potentially as a way to "bet-hedge" against the risk of the loss of any one friend. Gerry wrote a paper about this and you can find his results here: https://doi.org/10.1098/rsbl.2017.0112.

In this version of the game, you will play the "Social Foraging" version again. However, this time you will use the first 10 seconds of the game to pick THREE BUDDIES. Once the first 10 seconds have passed, your goals are now to (1) visit the cows to forage, and (2) spend as much time as you can near all three of your buddies.

Play the game, then save your data as "bet_hedge.csv"


## **Q19: Bet-hedging buddies
**Which three bats did you pick as your buddies?** 
```
ADD YOUR ANSWER HERE

```


# Load, process, & view the data

Load data & process
```{r warning=FALSE}
bet_hedge.locs <- read_csv("bet_hedge.csv") #this is uploaded by the students #SOCFORG.csv

#this is backup data in case student data won't run (just delete the "#" from the start of the line below)
#bet_hedge.locs <- read_csv("example_bet_hedge.csv") 

#rename cols
colnames(bet_hedge.locs) <- c("times", "agent", "x", "y")

#rename bat IDs in raw data, make bat -1 the "Player"
bet_hedge.locs$batID <- ifelse(bet_hedge.locs$agent==-1, "Player", paste("Bat", formatC(bet_hedge.locs$agent, width=2, flag="0"), sep=" "))

```


# Find distances between bats and landmarks

Use the locations to find the distances between each bat and all landmarks at each time step
```{r}

   ts <- seq(0,750)
    ev10steps <- ts[(ts %% 10) == 0]
    ev10steps <- ev10steps[2:length(ev10steps)]
    
    
   #clean landmarks
    landmarks.tr <- subset(landmarks, select=c(landmark, landmarkID, x, y))
    colnames(landmarks.tr) <- c("landmark", "landmarkID", "land.x", "land.y")  
    
    #make an empty dataframe to write to
    distance_landmarks <- data.frame(times=integer(),
                                     batID=character(),
                                     landmark=character(),
                                     landmarkID=character(),
                                     dist.class=character())
    
    #Loop over all bat locations to find distances between each bat and each landmark
    for (step in 2:length(ev10steps)) { #step=1
      loop.step <- ev10steps[step]
      
      #if no data at that timestep, skip
      loop.data <- if(nrow(subset(socfor.locs, times==loop.step))<1) next #skip if no data at this ts
      
      #otherwise, subset the data
      loop.data <- subset(socfor.locs, times==loop.step)
      
      #find distance from bats to all landmarks
      landmark.combos <- merge(loop.data, landmarks.tr)
      landmark.combos <- landmark.combos %>% mutate(dist=sqrt((x-land.x)^2 + (y-land.y)^2))
      #set categories of "near" or "not near" based on distance to them
      landmark.combos$dist.class <- ifelse(landmark.combos$dist<=5, "near", "not.near")
      
      #if no landmarks are near, skip to the next timestep
      if(nrow(subset(landmark.combos, dist.class=="near"))<1) next #skip if no bats are near
      
      #if any landmarks are near, subset the data
      landmark.combos.sub <- subset(landmark.combos, dist.class=="near")
      landmark.combos.subtr <- subset(landmark.combos.sub, select=c(times, batID, landmark, landmarkID, dist.class))
      
      
      #write data to save
      distance_landmarks <- rbind.data.frame(distance_landmarks, landmark.combos.subtr)
      
    }
    
#View results
rmarkdown::paged_table(distance_landmarks, options = NULL)

#summarize how many times each bat was near a roost or cow, and how many of each it visited
summ_landmarks <- distance_landmarks %>% group_by(batID, landmark, landmarkID) %>%
  summarize(times.near=n())

unique.landmarks <- summ_landmarks %>% group_by(batID, landmark) %>% summarize(unique.visitsXtype=n())
unique.landmarks_cows <- subset(unique.landmarks, landmark=="cow")

all.bats <- as.data.frame(unique(socfor.locs$batID))
colnames(all.bats) <- "batID"

unique.landmarks_cows <- merge(all.bats, unique.landmarks_cows, by="batID", all.x=TRUE, fill=0)
unique.landmarks_cows$unique.visitsXtype[is.na(unique.landmarks_cows$unique.visitsXtype)] <- 0

mean.NPC.cows <- mean(unique.landmarks_cows$unique.visitsXtype[unique.landmarks_cows$batID!="Player"])
n.player.cows <-unique.landmarks_cows$unique.visitsXtype[unique.landmarks_cows$batID=="Player"]

```


## Plot number of cows each bat found
```{r}
#plot number of cows discovered
ggplot(unique.landmarks_cows, aes(x=batID, y=unique.visitsXtype, 
                                  fill = ifelse(batID == "Player", "Player", "NPC bats"))) +
  geom_bar(stat="identity") +
  labs(x="Bats", 
       y="Number of cows found", 
       title = "Bat trajectories: social foraging") +
  ## add manual color scale
  scale_fill_manual("legend",         ###### in this call: colour change
                    values = c("Player" = "red", "NPC bats" = "saddlebrown")) +
  theme(plot.title = element_text(hjust = 0.5),
        panel.grid.major.y = element_line(color = "grey",
                                          linewidth = 0.5,
                                          linetype = 1),
        axis.line = element_line(colour = "black"),
        panel.border = element_rect(colour = "black", fill=NA, linewidth=0.5),
        legend.position="bottom",
        axis.text.x=element_text(angle = 90, vjust = 0.5, hjust=1)) +
  annotate("text", x=1, y=7, hjust = 0,
           label= paste0("Mean number cows found by NPC bats = ", round(mean.NPC.cows,2))) +
  annotate("text", x=1, y=6.5, hjust = 0,
           label= paste0("Number cows found by player = ", n.player.cows))
```

## ** Q20: Bet-hedging foraging success

**How many cows did you visit while foraging?**  
```
ADD YOUR ANSWER HERE

```

**Did any other bats find cows?**
```
ADD YOUR ANSWER HERE

```

**Which other bats were successful foragers and how many cows did they find?**  
```
ADD YOUR ANSWER HERE

```
**Is bet-hedging potentially a successful foraging strategy that you'd expect real bats to use? Why or why not?**
```
ADD YOUR ANSWER HERE

```

# Use location data to find distances between all bats
```{r}
   #for each timestep expand.grid to find all id combos, delete same ids
    ts <- seq(0,750)
    ev10steps <- ts[(ts %% 10) == 0]
    ev10steps <- ev10steps[2:length(ev10steps)]
    

    distance_bats <- data.frame(time=integer(),
                                batA=character(),
                                batB=character(),
                                dist.class=character())
    
    
    for (step in 1:length(ev10steps)) { #step=41
      loop.step <- ev10steps[step]
      #if no data at that timestep, skip
      loop.data <- if(nrow(subset(socfor.locs, times==loop.step))<1) next #skip if no data at this ts
      #otherwise, subset the data
      loop.data <- subset(socfor.locs, times==loop.step) 
      
      #find distance from each bat to each other bat
      loop.data$joiner <- 1
      all.combos <- merge(loop.data, loop.data, by="joiner")
      all.combos <- subset(all.combos, batID.x!=batID.y)
      all.combos <- all.combos %>% mutate(dist=sqrt((x.x-x.y)^2 + (y.x-y.y)^2))
      all.combos$dist.class <- ifelse(all.combos$dist<=5, "near", "not.near")
      
      #if no bats are near, skip to the next timestep
      all.combos.sub <- if(nrow(subset(all.combos, dist.class=="near"))<1) next #skip if no bats are near
      #if any bats are near, subset the data
      all.combos.sub <- subset(all.combos, dist.class=="near")
      
      all.combos.sub.tr <- subset(all.combos.sub, select=c(times.x, batID.x, batID.y, dist.class))
      colnames(all.combos.sub.tr) <- c("time", "batA", "batB", "dist.class")
      
      #write data to save
      distance_bats <- rbind.data.frame(distance_bats, all.combos.sub.tr)
      
    }

# view data structure
rmarkdown::paged_table(distance_bats, options = NULL)

```


# Summarize inter-bat proximities & compare network measures 

Now we'll quantify and plot the social networks for the bats in the bet-hedging version of the social foraging game. These networks will summarize the proximity network, where we'll count the number of times each bat was observed as "near" other bats. 

```{r}
# set up attributes

all.bats <- as.data.frame(unique(socfor.locs$batID))
colnames(all.bats) <- "batID"

all.bats$node.type <- ifelse(all.bats$batID=="Player", "Player", "NPC Bat")
all.bats$node.color <- ifelse(all.bats$batID=="Player", "red", "saddlebrown")
all.bats$bat.name <- ifelse(all.bats$batID=="Player", "ME", str_sub(all.bats$batID, start= -2))

summary_social <- distance_bats %>% group_by(batA, batB) %>%
  summarize(n.near =n())

# view data structure
head(summary_social)


g <- graph_from_data_frame(summary_social, directed=FALSE) 
g
g <- as.undirected(g, mode="mutual")

# add attributes
V(g)$bat.name <- all.bats[match(V(g)$name, all.bats$batID), "bat.name"]
V(g)$node.color <- all.bats[match(V(g)$name, all.bats$batID), "node.color"]

```

## Network summaries on thresholded network
Now we are going to analyze the bet-hedging game data, removing some of the rarer proximity observations like we did earlier for the social foraging game (1 buddy). We'll use a threshold of 10: the code below deletes any connections between bats who were "near" each other less than 10 times during the game. 

```{r}
g2 <- delete.edges(g, which(E(g)$n.near <10))

de <- igraph::degree(g2)/2
strength <- strength(g2, weights=E(g2)$n.near)/2

edge_density(g2)

# How social is each bat?
# add summary for n bats near ("degree") and n times near any bat??? TKTK
network_summs <- data.frame(batID=V(g2)$name, n.bats.near=de, times.near.others=strength)

# view data structure
rmarkdown::paged_table(network_summs, options = NULL)
```

## Plot network summaries
```{r}
NPCs.netsum <- subset(network_summs, batID!="Player")
player.netsum <- subset(network_summs, batID=="Player")


#degree
player_degree <- player.netsum$n.bats.near
plot_degree <- ggplot(NPCs.netsum, aes(5, n.bats.near)) +
  geom_boxplot(color="saddlebrown", fill="saddlebrown", alpha=0.2, outlier.shape = NA) +
  geom_jitter(width = 0.3, size=5, pch=21, col="white", bg="saddlebrown") +
  ylim(0,max(c(NPCs.netsum$n.bats.near,player.netsum$n.bats.near))) +
  ggtitle("Network degree") + 
  ylab("Number of unique bats encountered") +
  geom_point(aes(y=player_degree, x=5), col="black", bg="red", size=5, pch=23) +
  #  geom_point(aes(y=player.dirchange), col="black", bg="red", size=5, pch=23) +
  
  theme(plot.title = element_text(hjust = 0.5),
        axis.title.x=element_blank(),
        axis.text.x=element_blank(),
        axis.ticks.x=element_blank(),
        panel.background = element_blank(),
        panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(),
        axis.line = element_line(colour = "black"),
        panel.border = element_rect(colour = "black", fill=NA, linewidth=0.5))

#strength
player_strength <- player.netsum$times.near.others
plot_strength <- ggplot(NPCs.netsum, aes(5, times.near.others)) +
  geom_boxplot(color="saddlebrown", fill="saddlebrown", alpha=0.2, outlier.shape = NA) +
  geom_jitter(width = 0.3, size=5, pch=21, col="white", bg="saddlebrown") +
  ylim(0,max(c(NPCs.netsum$times.near.others,player.netsum$times.near.others))) +
  ggtitle("Network strength") + 
  ylab("Number encounters with other bats") +
  geom_point(aes(y=player_strength, x=5), col="black", bg="red", size=5, pch=23) +
  #  geom_point(aes(y=player.dirchange), col="black", bg="red", size=5, pch=23) +
  
  theme(plot.title = element_text(hjust = 0.5),
        axis.title.x=element_blank(),
        axis.text.x=element_blank(),
        axis.ticks.x=element_blank(),
        panel.background = element_blank(),
        panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(),
        axis.line = element_line(colour = "black"),
        panel.border = element_rect(colour = "black", fill=NA, linewidth=0.5))

# plot all together to compare
gridExtra::grid.arrange(plot_degree, plot_strength, ncol=2,
                        top=textGrob("Bat trajectories: social foraging"))
```

## ** Q21: Compare network metrics
**For bet-hedging foraging, compare your social measures to the NPC bats. Were you behaving "normally" compared to the other bats? If not, how did your movements cause you to have different social measures than the NPC bats?**
```
ADD YOUR ANSWER HERE

```


## Plot the proximity network without rare connections
```{r fig13, fig.height = 8, fig.width = 8}


#Plot the network
set.seed(42)
plot(g2, 
     edge.width=E(g2)$n.near/3,
     edge.color=alpha("black", 0.4),
     main= "Bat trajectories: social foraging", 
     #sub=paste0("Network density = ", round(edge_density(g),2)),
     vertex.size=17,
     vertex.color=V(g2)$node.color,
     vertex.label.family="Arial Black",
     vertex.label.font=2,
     vertex.label.cex=0.75,
     vertex.label=V(g2)$bat.name, 
     vertex.label.color="white",
     edge.curved=FALSE)

```

# Find strongest-preferred bats & plot

Find each bat's strongest partner
```{r}
top3associates <- summary_social %>% 
  group_by(batA) %>%
  arrange(desc(n.near)) %>% 
  slice(1:3) %>%
  arrange(batA)


rmarkdown::paged_table(top3associates, options = NULL)

```

Plot strongest partners
```{r fig14, fig.height = 8, fig.width = 8}
#set max axes for better labeling
max.y <- max(top3associates$n.near)+6

#barplot most-preferred associates and how often each bat was near their preferred
top3assos <- ggplot(top3associates, aes(x=batB, y=n.near, group=1, fill = ifelse(batA == "Player", "Player", "NPC bats"))) +
  geom_bar(stat="identity") +
  geom_text(aes(label = stringr::str_wrap(batB, 3)), 
            vjust = -0.2, 
            colour = "black",
            size=3,
            fontface = "italic") +
  ylim(0,max.y) + #set y limits for nicer labels
  labs(title="Stongest-preferred associates", 
       subtitle= "Bat trajectories: social foraging",
       x="Bats", 
       y="Number observations near favorite") +
  ## add manual color scale
  scale_fill_manual("legend",  
                    values = c("Player" = "red", "NPC bats" = "saddlebrown")) +
  theme(plot.title = element_text(hjust = 0.5),
        panel.grid.major.y = element_line(color = "grey",
                                          linewidth = 0.5,
                                          linetype = 1),
        axis.line = element_line(colour = "black"),
        panel.border = element_rect(colour = "black", fill=NA, linewidth=0.5),
        legend.position="bottom",
        axis.text.x=element_text(angle = 90, vjust = 0.5, hjust=1),
        aspect.ratio=1) +
  facet_wrap(~ batA,ncol = 5)

top3assos
```

## Compare each trajectory & plot
To visualize how well you matched the movements of your closest 3 associates (hopefully the three "buddies" you chose!), we'll plot your trajectory in red and your closest three associate's trajectories in brown. 

This code chunk processes the data and finds your "top three associates":
```{r}
top3associates.player <- subset(top3associates, batA=="Player")

player.top3assoIDs <- top3associates.player$batB # make a vector of names of all the player's top associates

top3asso.locs <- bet_hedge.locs[bet_hedge.locs$batID %in% player.top3assoIDs,] # subset the location data to only include player's top associate data

colnames(top3asso.locs) <- c("times", "agent", "x", "y", "top.assoID")

unique(top3asso.locs$top.assoID) # check that it worked!

player.locs <- subset(bet_hedge.locs, batID=="Player") # subset the location data to only include player's data
  
unique(player.locs$batID) # check that it worked!

# PLOT

under <- ggplot(player.locs, aes(x, y)) +
  geom_path(colour="red", linewidth=1.5, alpha=0.45) +
  xlim(0,50) +
  ylim(50,0) +
  labs(title = "Bat trajectories: social foraging, top associates of Player",
       subtitle = "Trajectories: Red=Player, Brown=Top associates; roost locations=green, cow locations=grey") +
  #set theme for plots
  theme(aspect.ratio=1,
        panel.background = element_blank(),
        panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(),
        axis.line = element_line(colour = "black"),
        panel.border = element_rect(colour = "black", fill=NA, linewidth=0.5),
        legend.position="bottom", legend.direction="horizontal") 

upper <- under + 
        geom_path(data=top3asso.locs, aes(x=x, y=y, group=top.assoID), colour="saddlebrown", linewidth=1.0,) +
        #add cows and roosts first so they plot over trajectories
        geom_point(data=locs.cows, aes(x=x, y=y), colour="darkgrey", size=3, pch=16) +
        geom_point(data=locs.roosts, aes(x=x, y=y), colour="green", size=3, pch=18) +
        facet_wrap(~ top.assoID) 

upper
  
```

## **Q22: Trajectory match for bet-hedging
**For bet-hedging foraging, how well did you overlap with each of your three buddies? Were there times when you had to choose which buddy to follow and abandon another buddy? How did you decide who to follow?**
```
ADD YOUR ANSWER HERE

```

# Final questions

## ** Q23: Foraging rules & surviving as a bat
**In the social foraging game, you had two "rules" you used to make your movement decisions: you wanted to find cows to forage on and you wanted to stay relatively close to your chosen "buddy". Real bats can use similar rules to structure their movements, or may do something different. What rules would you need in the following scenarios?**

**Scenario 1: Preferred roostmates do not coordinate movements outside the roost while foraging.** 

**What rules should the player and the NPC bats follow in a game like Scenario 1?**
```
ADD YOUR ANSWER HERE
```

**If you were a researcher in the field studying these bats, how could you tell whether bats were following Scenario 1? What would you look for? How would you tell which bats preferred each other?**
```
ADD YOUR ANSWER HERE
```

**Scenario 2: Preferred roostmates coordinate their departures from the roost but avoid foraging with each other** 

**What rules should the player and the NPC bats follow in a game like Scenario 2?**
```
ADD YOUR ANSWER HERE
```

**If you were a researcher in the field studying these bats, how could you tell whether bats were following Scenario 2? What would you look for? How would you tell which bats preferred each other?**
```
ADD YOUR ANSWER HERE
```

**Scenario 3: All roostmates depart and forage as a group.**

**What rules should the player and the NPC bats follow in a game like Scenario 3?**

```
ADD YOUR ANSWER HERE
```

**If you were a researcher in the field studying these bats, how could you tell whether bats were following Scenario 3? What would you look for? How would you tell which bats preferred each other?**
```
ADD YOUR ANSWER HERE
```

## **Q24: Long-term social strategies for survival

**Vampire bats can share food with each other if one bat isn't successful at foraging, but generally only share blood when they have a strong relationship. Food sharing occurs after foraging once bats have returned to the roost. If you are a bat living in an uncertain environment, where your changes of being unsuccessful at foraging and needing food sharing are higher, what social strategies could you use to increase your chances of survival?**

**How would you change your foraging patterns to increase your chances of survival? What strategy would you use and what rules would you use to move around?**
```
ADD YOUR ANSWER HERE
```

**How would you change your roosting patterns to increase your chances of survival? What strategy would you use and what rules would you use to decide which roost to use and who to share a roost with?**
```
ADD YOUR ANSWER HERE
```



########### 
# Last task
########### 

**At the end of the lab today, you'll compile everything you did into one document. This will be an HTML document which you can view using any browser window. It is very nice for scrolling through (no page breaks) and will have a clickable table of contents as well as a floating outline to the left side.

TO COMPILE YOUR FILE:

1. Finish all the coding and add all your answers the the text blocks. Make sure you keep all the backquotes, and these must all be on their own lines without any text.

2. At the top part of your screen, near the SAVE button, you will find a button called "Knit". Click it and choose "Knit to HTML".

3. You'll see an update on the percent progress in your console area (bottom of your screen). 

4. Once it reaches 100%, a new window should pop up and show you the compiled file. If you get an error window, choosing "Try Again" or "Open in Browser" usually fixes it.

5. If you get an error in your console and the file does not knit properly, the error code should mention where in your code threw the error. Trace it back and make sure you don't have any typeos and you didn't accidentally delete any backquotes, etc. Then just try to knit again (click the button as in step 2).

6. Once you have your HTML file knitted, it will appear in your file list (right part of your screen under the "Files" tab). To download your Lab Report, click the checkbox next to the file "analysis_code.html". Click "More" from the options at the top of this panel. Choose "Export" and save your HTML file to your computer. HTML files can then be uploaded to Canvas (etc.) as submitted assignments, submitted via email, etc.




## Formatting for the HTML file
This section sets some formatting rules to produce the lab report (you don't need to run it in R Markdown, this is only important at the end when you Knit the HTML file)
```{css, echo=FALSE}
pre {
  max-height: 300px;
  overflow-y: auto;
}

pre[class] {
  max-height: 250px;
}

.scroll-250 {
  max-height: 250px;
  overflow-y: auto;
  background-color: inherit;
}
```